<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="serf, header, diff" />
    <meta name="description" content="Diff for header files between 1.3.9 and current versions of serf" />
    <link rel="stylesheet" type="text/css" href="../../../../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../../../../css/headers_diff.css" />
    
    
    <title>
        serf: headers diff between 1.3.9 and current versions
    </title>
    
    </head>

<body>
<table width='100%' cellpadding='0' cellspacing='0'><tr><td><table cellpadding='0' cellspacing='0'><tr><td align='center'><h1 class='tool'><a title='ABI tracker for serf' href='../../../../timeline/serf/index.html' class='tool'>ABI<br/>Tracker</a></h1></td><td width='30px;'></td><td><h1>(serf)</h1></td></tr></table><hr/>
<br/>
<br/>
<h1>Headers diff: <span class='version'>1.3.9</span> vs <span class='version'>current</span></h1><br/><br/> 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;serf.h (1.3.9)&nbsp;</th><th> </th><th>&nbsp;serf.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 56<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 56<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">typedef struct serf_bucket_type_t serf_bucket_type_t;</td><td> </td><td class="right">typedef struct serf_bucket_type_t serf_bucket_type_t;</td></tr>
      <tr><td class="left">typedef struct serf_bucket_alloc_t serf_bucket_alloc_t;</td><td> </td><td class="right">typedef struct serf_bucket_alloc_t serf_bucket_alloc_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct serf_connection_t serf_connection_t;</td><td> </td><td class="right">typedef struct serf_connection_t serf_connection_t;</td></tr>
      <tr><td class="left">typedef struct serf_listener_t serf_listener_t;</td><td> </td><td class="right">typedef struct serf_listener_t serf_listener_t;</td></tr>
      <tr><td class="left">typedef struct serf_incoming_t serf_incoming_t;</td><td> </td><td class="right">typedef struct serf_incoming_t serf_incoming_t;</td></tr>
      <tr><td class="left">typedef struct serf_incoming_request_t serf_incoming_request_t;</td><td> </td><td class="right">typedef struct serf_incoming_request_t serf_incoming_request_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct serf_request_t serf_request_t;</td><td> </td><td class="right">typedef struct serf_request_t serf_request_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#if 0</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_connection_type_t serf_connection_type_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_protocol_t serf_protocol_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_protocol_type_t serf_protocol_type_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif /* Connection and protocol API v2 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_config_t serf_config_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @defgroup serf high-level constructs</td><td> </td><td class="right"> * @defgroup serf high-level constructs</td></tr>
      <tr><td class="left"> * @ingroup serf</td><td> </td><td class="right"> * @ingroup serf</td></tr>
      <tr><td class="left"> * @{</td><td> </td><td class="right"> * @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Serf-specific error codes</td><td> </td><td class="right"> * Serf-specific error codes</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_ERROR_RANGE 100</td><td> </td><td class="right">#define SERF_ERROR_RANGE 100</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 94<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 102<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define SERF_ERROR_DECOMPRESSION_FAILED (SERF_ERROR_START + 4)</td><td> </td><td class="right">#define SERF_ERROR_DECOMPRESSION_FAILED (SERF_ERROR_START + 4)</td></tr>
      <tr><td class="left">/* This code is for when a response received from a http server is not in</td><td> </td><td class="right">/* This code is for when a response received from a http server is not in</td></tr>
      <tr><td class="left"> * http-compliant syntax. */</td><td> </td><td class="right"> * http-compliant syntax. */</td></tr>
      <tr><td class="left">#define SERF_ERROR_BAD_HTTP_RESPONSE (SERF_ERROR_START + 5)</td><td> </td><td class="right">#define SERF_ERROR_BAD_HTTP_RESPONSE (SERF_ERROR_START + 5)</td></tr>
      <tr><td class="left">/* The server sent less data than what was announced. */</td><td> </td><td class="right">/* The server sent less data than what was announced. */</td></tr>
      <tr><td class="left">#define SERF_ERROR_TRUNCATED_HTTP_RESPONSE (SERF_ERROR_START + 6)</td><td> </td><td class="right">#define SERF_ERROR_TRUNCATED_HTTP_RESPONSE (SERF_ERROR_START + 6)</td></tr>
      <tr><td class="left">/* The proxy server returned an error while setting up the SSL tunnel. */</td><td> </td><td class="right">/* The proxy server returned an error while setting up the SSL tunnel. */</td></tr>
      <tr><td class="left">#define SERF_ERROR_SSLTUNNEL_SETUP_FAILED (SERF_ERROR_START + 7)</td><td> </td><td class="right">#define SERF_ERROR_SSLTUNNEL_SETUP_FAILED (SERF_ERROR_START + 7)</td></tr>
      <tr><td class="left">/* The server unexpectedly closed the connection prematurely. */</td><td> </td><td class="right">/* The server unexpectedly closed the connection prematurely. */</td></tr>
      <tr><td class="left">#define SERF_ERROR_ABORTED_CONNECTION (SERF_ERROR_START + 8)</td><td> </td><td class="right">#define SERF_ERROR_ABORTED_CONNECTION (SERF_ERROR_START + 8)</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Generic 'The line too long'. Used internally. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_LINE_TOO_LONG (SERF_ERROR_START + 9)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The HTTP response status line too long. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_STATUS_LINE_TOO_LONG (SERF_ERROR_START + 10)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The HTTP response header too long. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_RESPONSE_HEADER_TOO_LONG (SERF_ERROR_START + 11)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The connection to the server timed out. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_CONNECTION_TIMEDOUT (SERF_ERROR_START + 12)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The stream returned less data than was expected */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_TRUNCATED_STREAM (SERF_ERROR_START + 13)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The stream is empty */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_EMPTY_STREAM (SERF_ERROR_START + 14)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* An empty read was returned. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_EMPTY_READ (SERF_ERROR_START + 15)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Http-2 stream errors, mapped into our error range */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_NO_ERROR (SERF_ERROR_START + 50)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_PROTOCOL_ERROR (SERF_ERROR_START + 51)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_INTERNAL_ERROR (SERF_ERROR_START + 52)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_FLOW_CONTROL_ERROR (SERF_ERROR_START + 53)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_SETTINGS_TIMEOUT (SERF_ERROR_START + 54)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_STREAM_CLOSED (SERF_ERROR_START + 55)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_FRAME_SIZE_ERROR (SERF_ERROR_START + 56)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_REFUSED_STREAM (SERF_ERROR_START + 57)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_CANCEL (SERF_ERROR_START + 58)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_COMPRESSION_ERROR (SERF_ERROR_START + 59)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_CONNECT_ERROR (SERF_ERROR_START + 60)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_ENHANCE_YOUR_CALM (SERF_ERROR_START + 61)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_INADEQUATE_SECURITY (SERF_ERROR_START + 62)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_HTTP2_HTTP_1_1_REQUIRED (SERF_ERROR_START + 63)</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* SSL certificates related errors */</td><td> </td><td class="right">/* SSL certificates related errors */</td></tr>
      <tr><td class="left">#define SERF_ERROR_SSL_CERT_FAILED (SERF_ERROR_START + 70)</td><td> </td><td class="right">#define SERF_ERROR_SSL_CERT_FAILED (SERF_ERROR_START + 70)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* SSL communications related errors */</td><td> </td><td class="right">/* SSL communications related errors */</td></tr>
      <tr><td class="left">#define SERF_ERROR_SSL_COMM_FAILED (SERF_ERROR_START + 71)</td><td> </td><td class="right">#define SERF_ERROR_SSL_COMM_FAILED (SERF_ERROR_START + 71)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* SSL handshake failed */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_SSL_SETUP_FAILED (SERF_ERROR_START + 72)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Serf-internal error code, raised when the server initiates SSL renegotia</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   on a connection that uses HTTP pipelining. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_SSL_NEGOTIATE_IN_PROGRESS (SERF_ERROR_START + 73)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* General authentication related errors */</td><td> </td><td class="right">/* General authentication related errors */</td></tr>
      <tr><td class="left">#define SERF_ERROR_AUTHN_FAILED (SERF_ERROR_START + 90)</td><td> </td><td class="right">#define SERF_ERROR_AUTHN_FAILED (SERF_ERROR_START + 90)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* None of the available authn mechanisms for the request are supported */</td><td> </td><td class="right">/* None of the available authn mechanisms for the request are supported */</td></tr>
      <tr><td class="left">#define SERF_ERROR_AUTHN_NOT_SUPPORTED (SERF_ERROR_START + 91)</td><td> </td><td class="right">#define SERF_ERROR_AUTHN_NOT_SUPPORTED (SERF_ERROR_START + 91)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Authn was requested by the server but the header lacked some attribute  
*/</td><td> </td><td class="right">/* Authn was requested by the server but the header lacked some attribute  
*/</td></tr>
      <tr><td class="left">#define SERF_ERROR_AUTHN_MISSING_ATTRIBUTE (SERF_ERROR_START + 92)</td><td> </td><td class="right">#define SERF_ERROR_AUTHN_MISSING_ATTRIBUTE (SERF_ERROR_START + 92)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Authentication handler initialization related errors */</td><td> </td><td class="right">/* Authentication handler initialization related errors */</td></tr>
      <tr><td class="left">#define SERF_ERROR_AUTHN_INITALIZATION_FAILED (SERF_ERROR_START + 93)</td><td> </td><td class="right">#define SERF_ERROR_AUTHN_INITALIZATION_FAILED (SERF_ERROR_START + 93)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The user credentials were rejected by the server */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_AUTHN_CREDENTIALS_REJECTED (SERF_ERROR_START + 94)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Error code reserved for use in the test suite. */</td><td> </td><td class="right">/* Error code reserved for use in the test suite. */</td></tr>
      <tr><td class="left">#define SERF_ERROR_ISSUE_IN_TESTSUITE (SERF_ERROR_START + 99)</td><td> </td><td class="right">#define SERF_ERROR_ISSUE_IN_TESTSUITE (SERF_ERROR_START + 99)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* This macro groups errors potentially raised when reading a http response
.  */</td><td> </td><td class="right">/* This macro groups errors potentially raised when reading a http response
.  */</td></tr>
      <tr><td class="left">#define SERF_BAD_RESPONSE_ERROR(status) ((status) \</td><td> </td><td class="right">#define SERF_BAD_RESPONSE_ERROR(status) ((status) \</td></tr>
      <tr><td class="left">    &amp;&amp; ((SERF_ERROR_DECOMPRESSION_FAILED == (status)) \</td><td> </td><td class="right">    &amp;&amp; ((SERF_ERROR_DECOMPRESSION_FAILED == (status)) \</td></tr>
      <tr><td class="left">        ||(SERF_ERROR_BAD_HTTP_RESPONSE == (status)) \</td><td> </td><td class="right">        ||(SERF_ERROR_BAD_HTTP_RESPONSE == (status)) \</td></tr>
      <tr><td class="left">        ||(SERF_ERROR_TRUNCATED_HTTP_RESPONSE == (status))))</td><td> </td><td class="right">        ||(SERF_ERROR_TRUNCATED_HTTP_RESPONSE == (status))))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 334<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 382<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All temporary allocations should be made in @a pool.</td><td> </td><td class="right"> * All temporary allocations should be made in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef void (*serf_connection_closed_t)(</td><td> </td><td class="right">typedef void (*serf_connection_closed_t)(</td></tr>
      <tr><td class="left">    serf_connection_t *conn,</td><td> </td><td class="right">    serf_connection_t *conn,</td></tr>
      <tr><td class="left">    void *closed_baton,</td><td> </td><td class="right">    void *closed_baton,</td></tr>
      <tr><td class="left">    apr_status_t why,</td><td> </td><td class="right">    apr_status_t why,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Like serf_connection_closed_t, but applies to incoming connections.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_incoming_closed_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_t *incoming,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *closed_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_status_t why,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Response data has arrived and should be processed.</td><td> </td><td class="right"> * Response data has arrived and should be processed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Whenever response data for @a request arrives (initially, or continued d
ata</td><td> </td><td class="right"> * Whenever response data for @a request arrives (initially, or continued d
ata</td></tr>
      <tr><td class="left"> * arrival), this handler is invoked. The response data is available in the</td><td> </td><td class="right"> * arrival), this handler is invoked. The response data is available in the</td></tr>
      <tr><td class="left"> * @a response bucket. The @a handler_baton is passed along from the baton</td><td> </td><td class="right"> * @a response bucket. The @a handler_baton is passed along from the baton</td></tr>
      <tr><td class="left"> * provided by the request setup callback (@see serf_request_setup_t).</td><td> </td><td class="right"> * provided by the request setup callback (@see serf_request_setup_t).</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The handler MUST process data from the @a response bucket until the</td><td> </td><td class="right"> * The handler MUST process data from the @a response bucket until the</td></tr>
      <tr><td class="left"> * bucket's read function states it would block (see APR_STATUS_IS_EAGAIN).</td><td> </td><td class="right"> * bucket's read function states it would block (see APR_STATUS_IS_EAGAIN).</td></tr>
      <tr><td class="left"> * The handler is invoked only when new data arrives. If no further data</td><td> </td><td class="right"> * The handler is invoked only when new data arrives. If no further data</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 388<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 445<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    int code, const char *authn_type,</td><td> </td><td class="right">    int code, const char *authn_type,</td></tr>
      <tr><td class="left">    const char *realm,</td><td> </td><td class="right">    const char *realm,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new connection associated with the @a ctx serf context.</td><td> </td><td class="right"> * Create a new connection associated with the @a ctx serf context.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If no proxy server is configured, a connection will be created to</td><td> </td><td class="right"> * If no proxy server is configured, a connection will be created to</td></tr>
      <tr><td class="left"> * (eventually) connect to the address specified by @a address. The address
 must</td><td> </td><td class="right"> * (eventually) connect to the address specified by @a address. The address
 must</td></tr>
      <tr><td class="left"> * live at least as long as @a pool (thus, as long as the connection object
).</td><td> </td><td class="right"> * live at least as long as @a pool (thus, as long as the connection object
).</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"> * If a proxy server is configured, @address will be ignored.</td><td> </td><td class="rblock"> * If a proxy server is configured, @a<span class="insert"> a</span>ddress will be ignored.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The connection object will be allocated within @a pool. Clearing or</td><td> </td><td class="right"> * The connection object will be allocated within @a pool. Clearing or</td></tr>
      <tr><td class="left"> * destroying this pool will close the connection, and terminate any</td><td> </td><td class="right"> * destroying this pool will close the connection, and terminate any</td></tr>
      <tr><td class="left"> * outstanding requests or responses.</td><td> </td><td class="right"> * outstanding requests or responses.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * When the connection is closed (upon request or because of an error),</td><td> </td><td class="right"> * When the connection is closed (upon request or because of an error),</td></tr>
      <tr><td class="left"> * then the @a closed callback is invoked, and @a closed_baton is passed.</td><td> </td><td class="right"> * then the @a closed callback is invoked, and @a closed_baton is passed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ### doc on setup(_baton). tweak below comment re: acceptor.</td><td> </td><td class="right"> * ### doc on setup(_baton). tweak below comment re: acceptor.</td></tr>
      <tr><td class="left"> * NULL may be passed for @a acceptor and @a closed; default implementation
s</td><td> </td><td class="right"> * NULL may be passed for @a acceptor and @a closed; default implementation
s</td></tr>
      <tr><td class="left"> * will be used.</td><td> </td><td class="right"> * will be used.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"> * <span class="delete">Note: t</span>he connection is not made immediately. It will be opened on</td><td> </td><td class="rblock"> * <span class="insert">@note T</span>he connection is not made immediately. It will be opened on</td></tr>
      <tr><td class="left"> * the next call to @see serf_context_run.</td><td> </td><td class="right"> * the next call to @see serf_context_run.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">serf_connection_t *serf_connection_create(</td><td> </td><td class="right">serf_connection_t *serf_connection_create(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_sockaddr_t *address,</td><td> </td><td class="right">    apr_sockaddr_t *address,</td></tr>
      <tr><td class="left">    serf_connection_setup_t setup,</td><td> </td><td class="right">    serf_connection_setup_t setup,</td></tr>
      <tr><td class="left">    void *setup_baton,</td><td> </td><td class="right">    void *setup_baton,</td></tr>
      <tr><td class="left">    serf_connection_closed_t closed,</td><td> </td><td class="right">    serf_connection_closed_t closed,</td></tr>
      <tr><td class="left">    void *closed_baton,</td><td> </td><td class="right">    void *closed_baton,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new connection associated with the @a ctx serf context.</td><td> </td><td class="right"> * Create a new connection associated with the @a ctx serf context.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Like @see serf_connection_create3 but with @a host_address set to @c NUL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">L.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_connection_create2(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_connection_t **conn,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_uri_t host_info,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_connection_setup_t setup,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *setup_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_connection_closed_t closed,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *closed_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Create a new connection associated with the @a ctx serf context.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="left"> * A connection will be created to (eventually) connect to the address</td><td> </td><td class="right"> * A connection will be created to (eventually) connect to the address</td></tr>
      <tr><td class="left"> * specified by @a address. The address must live at least as long as</td><td> </td><td class="right"> * specified by @a address. The address must live at least as long as</td></tr>
      <tr><td class="left"> * @a pool (thus, as long as the connection object).</td><td> </td><td class="right"> * @a pool (thus, as long as the connection object).</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock"> * <span class="delete">The</span> host address will be looked up based on the hostname in @a host_info</td><td> </td><td class="rblock"> * <span class="insert">If @a host_address is @c NULL, the</span> host address will be looked up</td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"> <span class="insert">*</span> based on the hostname in @a <span class="insert">host_info; otherwise @a host_address</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * will be used to connect and @a</span> host_info <span class="insert">will only be used for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * setting request headers.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The connection object will be allocated within @a pool. Clearing or</td><td> </td><td class="right"> * The connection object will be allocated within @a pool. Clearing or</td></tr>
      <tr><td class="left"> * destroying this pool will close the connection, and terminate any</td><td> </td><td class="right"> * destroying this pool will close the connection, and terminate any</td></tr>
      <tr><td class="left"> * outstanding requests or responses.</td><td> </td><td class="right"> * outstanding requests or responses.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * When the connection is closed (upon request or because of an error),</td><td> </td><td class="right"> * When the connection is closed (upon request or because of an error),</td></tr>
      <tr><td class="left"> * then the @a closed callback is invoked, and @a closed_baton is passed.</td><td> </td><td class="right"> * then the @a closed callback is invoked, and @a closed_baton is passed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ### doc on setup(_baton). tweak below comment re: acceptor.</td><td> </td><td class="right"> * ### doc on setup(_baton). tweak below comment re: acceptor.</td></tr>
      <tr><td class="left"> * NULL may be passed for @a acceptor and @a closed; default implementation
s</td><td> </td><td class="right"> * NULL may be passed for @a acceptor and @a closed; default implementation
s</td></tr>
      <tr><td class="left"> * will be used.</td><td> </td><td class="right"> * will be used.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock"> * <span class="delete">Note:</span> the connection is not made immediately. It will be opened on</td><td> </td><td class="rblock"> * <span class="insert">@note</span> the connection is not made immediately. It will be opened on</td></tr>
      <tr><td class="left"> * the next call to @see serf_context_run.</td><td> </td><td class="right"> * the next call to @see serf_context_run.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock">apr_status_t serf_connection_create<span class="delete">2</span>(</td><td> </td><td class="rblock">apr_status_t serf_connection_create<span class="insert">3</span>(</td></tr>
      <tr><td class="left">    serf_connection_t **conn,</td><td> </td><td class="right">    serf_connection_t **conn,</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_uri_t host_info,</td><td> </td><td class="right">    apr_uri_t host_info,</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_sockaddr_t *host_address,</span></td></tr>
      <tr><td class="left">    serf_connection_setup_t setup,</td><td> </td><td class="right">    serf_connection_setup_t setup,</td></tr>
      <tr><td class="left">    void *setup_baton,</td><td> </td><td class="right">    void *setup_baton,</td></tr>
      <tr><td class="left">    serf_connection_closed_t closed,</td><td> </td><td class="right">    serf_connection_closed_t closed,</td></tr>
      <tr><td class="left">    void *closed_baton,</td><td> </td><td class="right">    void *closed_baton,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef apr_status_t (*serf_accept_client_t)(</td><td> </td><td class="right">typedef apr_status_t (*serf_accept_client_t)(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    serf_listener_t *l,</td><td> </td><td class="right">    serf_listener_t *l,</td></tr>
      <tr><td class="left">    void *accept_baton,</td><td> </td><td class="right">    void *accept_baton,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 462<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 538<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">apr_status_t serf_listener_create(</td><td> </td><td class="right">apr_status_t serf_listener_create(</td></tr>
      <tr><td class="left">    serf_listener_t **listener,</td><td> </td><td class="right">    serf_listener_t **listener,</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    const char *host,</td><td> </td><td class="right">    const char *host,</td></tr>
      <tr><td class="left">    apr_uint16_t port,</td><td> </td><td class="right">    apr_uint16_t port,</td></tr>
      <tr><td class="left">    void *accept_baton,</td><td> </td><td class="right">    void *accept_baton,</td></tr>
      <tr><td class="left">    serf_accept_client_t accept_func,</td><td> </td><td class="right">    serf_accept_client_t accept_func,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_incoming_request_cb_t)(</span></td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_incoming_request_handler_t)(</span></td></tr>
      <tr><td class="lblock"><span class="delete">    serf_context_t *ctx,</span></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_request_t *req,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *request,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *handler_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_incoming_response_setup_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t **resp_bkt,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_request_t *req,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *setup_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_incoming_request_setup_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t **req_bkt,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *stream,</span></td></tr>
      <tr><td class="left">    serf_incoming_request_t *req,</td><td> </td><td class="right">    serf_incoming_request_t *req,</td></tr>
      <tr><td class="left">    void *request_baton,</td><td> </td><td class="right">    void *request_baton,</td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    <span class="insert">serf_incoming_request_handler_t *handler,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void **handler_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_response_setup_t *response_setup,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void **response_setup_baton,</span></td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ### Deprecated: can't do anything with request */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t(*serf_incoming_request_cb_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  serf_incoming_request_t *req,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  void *request_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ### Deprecated: Misses ssl support and actual</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       request handling. */</span></td></tr>
      <tr><td class="left">apr_status_t serf_incoming_create(</td><td> </td><td class="right">apr_status_t serf_incoming_create(</td></tr>
      <tr><td class="left">    serf_incoming_t **client,</td><td> </td><td class="right">    serf_incoming_t **client,</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_socket_t *insock,</td><td> </td><td class="right">    apr_socket_t *insock,</td></tr>
      <tr><td class="left">    void *request_baton,</td><td> </td><td class="right">    void *request_baton,</td></tr>
      <tr><td class="left">    serf_incoming_request_cb_t request,</td><td> </td><td class="right">    serf_incoming_request_cb_t request,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Creates a new client associated with @a ctx for socket @a insock. The cl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ient</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * takes responsibility for @a client_pool and will destroy it after the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * connection is closed. Typically this would be the same pool as where the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * incomming socket @a insock is allocated in.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This non-standard behavior is needed to support listeners inside the sam</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @a ctx instance without leaking memory for each used connections. Caller</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * might want to create a specific client pool if they use a non-standard</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * listening pattern.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Once the connection is setup @a setup will be called with @a setup_baton</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to setup the connection's bucket support.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * When the connection closed @a closed will be called with @a closed_baton</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> to</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * notify that the client and its pool are about to be destroyed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Once the connection is fully setup incoming requests will be routed to @</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">a</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * req_setup with @a req_setup_baton, to handle processing.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_incoming_create2(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_t **client,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_socket_t *insock,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_connection_setup_t setup,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *setup_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_closed_t closed,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *closed_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_request_setup_t req_setup,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *req_setup_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *client_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Allows creating a response before the request is completely</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   read. Will call the response create function if it hasn't</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   been called yet. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_incoming_response_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_request_t *request);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Reset the connection, but re-open the socket again.</td><td> </td><td class="right"> * Reset the connection, but re-open the socket again.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_connection_reset(</td><td> </td><td class="right">apr_status_t serf_connection_reset(</td></tr>
      <tr><td class="left">    serf_connection_t *conn);</td><td> </td><td class="right">    serf_connection_t *conn);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Close the connection associated with @a conn and cancel all pending requ
ests.</td><td> </td><td class="right"> * Close the connection associated with @a conn and cancel all pending requ
ests.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The closed callback passed to serf_connection_create() will be invoked</td><td> </td><td class="right"> * The closed callback passed to serf_connection_create() will be invoked</td></tr>
      <tr><td class="left"> * with APR_SUCCESS.</td><td> </td><td class="right"> * with APR_SUCCESS.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 510<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 653<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    serf_connection_t *conn,</td><td> </td><td class="right">    serf_connection_t *conn,</td></tr>
      <tr><td class="left">    unsigned int max_requests);</td><td> </td><td class="right">    unsigned int max_requests);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">void serf_connection_set_async_responses(</td><td> </td><td class="right">void serf_connection_set_async_responses(</td></tr>
      <tr><td class="left">    serf_connection_t *conn,</td><td> </td><td class="right">    serf_connection_t *conn,</td></tr>
      <tr><td class="left">    serf_response_acceptor_t acceptor,</td><td> </td><td class="right">    serf_response_acceptor_t acceptor,</td></tr>
      <tr><td class="left">    void *acceptor_baton,</td><td> </td><td class="right">    void *acceptor_baton,</td></tr>
      <tr><td class="left">    serf_response_handler_t handler,</td><td> </td><td class="right">    serf_response_handler_t handler,</td></tr>
      <tr><td class="left">    void *handler_baton);</td><td> </td><td class="right">    void *handler_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum serf_connection_framing_type_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  SERF_CONNECTION_FRAMING_TYPE_NONE = 0,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  SERF_CONNECTION_FRAMING_TYPE_HTTP1,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  SERF_CONNECTION_FRAMING_TYPE_HTTP2,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  SERF_CONNECTION_FRAMING_TYPE_FCGI</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} serf_connection_framing_type_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">* Sets the connection framing on the connection to the specified type. The</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">* NONE type specifies that the framing type is undetermined yet and no</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">* requests should be written to the connection until the framing type is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">* set. Connections default to HTTP1 framing.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">* @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void serf_connection_set_framing_type(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  serf_connection_t *conn,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  serf_connection_framing_type_t framing_type);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void serf_incoming_set_framing_type(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_t *client,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_connection_framing_type_t framing_type);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Setup the @a request for delivery on its connection.</td><td> </td><td class="right"> * Setup the @a request for delivery on its connection.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Right before this is invoked, @a pool will be built within the</td><td> </td><td class="right"> * Right before this is invoked, @a pool will be built within the</td></tr>
      <tr><td class="left"> * connection's pool for the request to use.  The associated response will</td><td> </td><td class="right"> * connection's pool for the request to use.  The associated response will</td></tr>
      <tr><td class="left"> * be allocated within that subpool. An associated bucket allocator will</td><td> </td><td class="right"> * be allocated within that subpool. An associated bucket allocator will</td></tr>
      <tr><td class="left"> * be built. These items may be fetched from the request object through</td><td> </td><td class="right"> * be built. These items may be fetched from the request object through</td></tr>
      <tr><td class="left"> * @see serf_request_get_pool or @see serf_request_get_alloc.</td><td> </td><td class="right"> * @see serf_request_get_pool or @see serf_request_get_alloc.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The content of the request is specified by the @a req_bkt bucket. When</td><td> </td><td class="right"> * The content of the request is specified by the @a req_bkt bucket. When</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 574<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 743<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * with @see serf_request_cancel.</td><td> </td><td class="right"> * with @see serf_request_cancel.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Invoking any calls other than @see serf_request_cancel before the setup</td><td> </td><td class="right"> * Invoking any calls other than @see serf_request_cancel before the setup</td></tr>
      <tr><td class="left"> * callback executes is not supported.</td><td> </td><td class="right"> * callback executes is not supported.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">serf_request_t *serf_connection_priority_request_create(</td><td> </td><td class="right">serf_request_t *serf_connection_priority_request_create(</td></tr>
      <tr><td class="left">    serf_connection_t *conn,</td><td> </td><td class="right">    serf_connection_t *conn,</td></tr>
      <tr><td class="left">    serf_request_setup_t setup,</td><td> </td><td class="right">    serf_request_setup_t setup,</td></tr>
      <tr><td class="left">    void *setup_baton);</td><td> </td><td class="right">    void *setup_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** The default request priority */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_REQUEST_PRIORITY_DEFAULT 0x1000</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Updates the request's priority information. Some protocol implementation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * such as HTTP/2 may use this information for response scheduling. The</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * actual behavior depends on the server, intermediate proxies and of cours</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the protocol implementation.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * It is recommended to prioritize a request before sending it to the serve</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * as that avoids race conditions and receiving unwanted results.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * If @a depends_on is set, then the request is marked as dependent on</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @a depends_on, and the result of @a request will only be received if</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * no progress can be made on @a depends_on itself.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @a priority is used to relatively prioritize multiple dependencies on th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * same target. Passing 0 will keep the original priority. In case of HTTP/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * this value is mapped to a 8 bit value by ignoring the lowest 8 bits.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * By default a request is created at priority SERF_REQUEST_PRIORITY_DEFAUL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">T.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * If @a exclusive is set to TRUE, then all existing dependencies on @a</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * depends_on will be updated to now depend on @a request, to make @a</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * request the only dependency of @a request. When FALSE, request will just</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * be added as a dependency.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void serf_connection_request_prioritize(serf_request_t *request,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        serf_request_t *depends_on,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        apr_uint16_t priority,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        int exclusive);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Returns detected network latency for the @a conn connection. Negative</td><td> </td><td class="right">/** Returns detected network latency for the @a conn connection. Negative</td></tr>
      <tr><td class="left"> *  value means that latency is unknwon.</td><td> </td><td class="right"> *  value means that latency is unknwon.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_interval_time_t serf_connection_get_latency(serf_connection_t *conn);</td><td> </td><td class="right">apr_interval_time_t serf_connection_get_latency(serf_connection_t *conn);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns the number of requests waiting to be sent over connection CONN.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">unsigned int serf_connection_queued_requests(serf_connection_t *conn);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns the total number of requests for which a response hasn't been</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * received yet on connection CONN. This includes requests:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - that are queued but not sent.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - that have been sent but no response has been completely received yet.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">unsigned int serf_connection_pending_requests(serf_connection_t *conn);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Check if a @a request has been completely written.</td><td> </td><td class="right">/** Check if a @a request has been completely written.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Returns APR_SUCCESS if the request was written completely on the connect
ion.</td><td> </td><td class="right"> * Returns APR_SUCCESS if the request was written completely on the connect
ion.</td></tr>
      <tr><td class="left"> * Returns APR_EBUSY if the request is not yet or partially written.</td><td> </td><td class="right"> * Returns APR_EBUSY if the request is not yet or partially written.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_request_is_written(</td><td> </td><td class="right">apr_status_t serf_request_is_written(</td></tr>
      <tr><td class="left">    serf_request_t *request);</td><td> </td><td class="right">    serf_request_t *request);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Cancel the request specified by the @a request object.</td><td> </td><td class="right"> * Cancel the request specified by the @a request object.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 689<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 905<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    apr_socket_t *skt,</td><td> </td><td class="right">    apr_socket_t *skt,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a bucket of type 'request bucket'.</td><td> </td><td class="right"> * Create a bucket of type 'request bucket'.</td></tr>
      <tr><td class="left"> * This is basically a wrapper around @a serf_bucket_request_create, which</td><td> </td><td class="right"> * This is basically a wrapper around @a serf_bucket_request_create, which</td></tr>
      <tr><td class="left"> * initializes the bucket using request, connection and/or context specific</td><td> </td><td class="right"> * initializes the bucket using request, connection and/or context specific</td></tr>
      <tr><td class="left"> * settings.</td><td> </td><td class="right"> * settings.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will set following header(s):</td><td> </td><td class="right"> * This function will set following header(s):</td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock"> * - Host: if the connection was created with <span class="delete">@a serf_connection_create2.</span></td><td> </td><td class="rblock"> * - Host: if the connection was created with <span class="insert">@see serf_connection_create2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *         or @see serf_connection_create3</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">serf_bucket_t *serf_request_bucket_request_create(</td><td> </td><td class="right">serf_bucket_t *serf_request_bucket_request_create(</td></tr>
      <tr><td class="left">    serf_request_t *request,</td><td> </td><td class="right">    serf_request_t *request,</td></tr>
      <tr><td class="left">    const char *method,</td><td> </td><td class="right">    const char *method,</td></tr>
      <tr><td class="left">    const char *uri,</td><td> </td><td class="right">    const char *uri,</td></tr>
      <tr><td class="left">    serf_bucket_t *body,</td><td> </td><td class="right">    serf_bucket_t *body,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @} */</td><td> </td><td class="right">/** @} */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 735<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 952<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * Note: an alternative to using this symbol would be for callers to see</td><td> </td><td class="right"> * Note: an alternative to using this symbol would be for callers to see</td></tr>
      <tr><td class="left"> * the SERF_NEWLINE_CR return value, and know that some "end of buffer" was</td><td> </td><td class="right"> * the SERF_NEWLINE_CR return value, and know that some "end of buffer" was</td></tr>
      <tr><td class="left"> * reached. While this works well for @see serf_util_readline, it does not</td><td> </td><td class="right"> * reached. While this works well for @see serf_util_readline, it does not</td></tr>
      <tr><td class="left"> * necessary work as well for buckets (there is no obvious "end of buffer",</td><td> </td><td class="right"> * necessary work as well for buckets (there is no obvious "end of buffer",</td></tr>
      <tr><td class="left"> * although there is an "end of bucket"). The other problem with that</td><td> </td><td class="right"> * although there is an "end of bucket"). The other problem with that</td></tr>
      <tr><td class="left"> * alternative is that developers might miss the condition. This symbol</td><td> </td><td class="right"> * alternative is that developers might miss the condition. This symbol</td></tr>
      <tr><td class="left"> * calls out the possibility and ensures that callers will watch for it.</td><td> </td><td class="right"> * calls out the possibility and ensures that callers will watch for it.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_NEWLINE_CRLF_SPLIT 0x0010</td><td> </td><td class="right">#define SERF_NEWLINE_CRLF_SPLIT 0x0010</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Used to indicate that length of remaining data in bucket is unknown. Se</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * serf_bucket_type_t-&gt;get_remaining().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LENGTH_UNKNOWN ((apr_uint64_t) -1)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">struct serf_bucket_type_t {</td><td> </td><td class="right">struct serf_bucket_type_t {</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /** name of this bucket type */</td><td> </td><td class="right">    /** name of this bucket type */</td></tr>
      <tr><td class="left">    const char *name;</td><td> </td><td class="right">    const char *name;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /**</td><td> </td><td class="right">    /**</td></tr>
      <tr><td class="left">     * Read (and consume) up to @a requested bytes from @a bucket.</td><td> </td><td class="right">     * Read (and consume) up to @a requested bytes from @a bucket.</td></tr>
      <tr><td class="left">     *</td><td> </td><td class="right">     *</td></tr>
      <tr><td class="left">     * A pointer to the data will be returned in @a data, and its length</td><td> </td><td class="right">     * A pointer to the data will be returned in @a data, and its length</td></tr>
      <tr><td class="left">     * is specified by @a len.</td><td> </td><td class="right">     * is specified by @a len.</td></tr>
      <tr><td class="left">     *</td><td> </td><td class="right">     *</td></tr>
      <tr><td class="left">     * The data will exist until one of two conditions occur:</td><td> </td><td class="right">     * The data will exist until one of two conditions occur:</td></tr>
      <tr><td class="left">     *</td><td> </td><td class="right">     *</td></tr>
      <tr><td class="left">     * 1) this bucket is destroyed</td><td> </td><td class="right">     * 1) this bucket is destroyed</td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock">     * 2) another call to any read function or to peek()</td><td> </td><td class="rblock">     * 2) another call to any read function<span class="insert">, get_remaining()</span> or to peek()</td></tr>
      <tr><td class="left">     *</td><td> </td><td class="right">     *</td></tr>
      <tr><td class="left">     * If an application needs the data to exist for a longer duration,</td><td> </td><td class="right">     * If an application needs the data to exist for a longer duration,</td></tr>
      <tr><td class="left">     * then it must make a copy.</td><td> </td><td class="right">     * then it must make a copy.</td></tr>
      <tr><td class="left">     */</td><td> </td><td class="right">     */</td></tr>
      <tr><td class="left">    apr_status_t (*read)(serf_bucket_t *bucket, apr_size_t requested,</td><td> </td><td class="right">    apr_status_t (*read)(serf_bucket_t *bucket, apr_size_t requested,</td></tr>
      <tr><td class="left">                         const char **data, apr_size_t *len);</td><td> </td><td class="right">                         const char **data, apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /**</td><td> </td><td class="right">    /**</td></tr>
      <tr><td class="left">     * Read (and consume) a line of data from @a bucket.</td><td> </td><td class="right">     * Read (and consume) a line of data from @a bucket.</td></tr>
      <tr><td class="left">     *</td><td> </td><td class="right">     *</td></tr>
      <tr><td class="left">     * The acceptable forms of a newline are given by @a acceptable, and</td><td> </td><td class="right">     * The acceptable forms of a newline are given by @a acceptable, and</td></tr>
      <tr><td class="left">     * the type found is returned in @a found. If a newline is not present</td><td> </td><td class="right">     * the type found is returned in @a found. If a newline is not present</td></tr>
      <tr><td class="left">     * in the returned data, then SERF_NEWLINE_NONE is stored into @a found
.</td><td> </td><td class="right">     * in the returned data, then SERF_NEWLINE_NONE is stored into @a found
.</td></tr>
      <tr><td class="left">     *</td><td> </td><td class="right">     *</td></tr>
      <tr><td class="left">     * A pointer to the data is returned in @a data, and its length is</td><td> </td><td class="right">     * A pointer to the data is returned in @a data, and its length is</td></tr>
      <tr><td class="left">     * specified by @a len. The data will include the newline, if present.</td><td> </td><td class="right">     * specified by @a len. The data will include the newline, if present.</td></tr>
      <tr><td class="left">     *</td><td> </td><td class="right">     *</td></tr>
      <tr><td class="left">     * Note that there is no way to limit the amount of data returned</td><td> </td><td class="right">     * Note that there is no way to limit the amount of data returned</td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock">     * by this function.</td><td> </td><td class="rblock">     * by this function.<span class="insert"> @see serf_bucket_limited_readline().</span></td></tr>
      <tr><td class="left">     *</td><td> </td><td class="right">     *</td></tr>
      <tr><td class="left">     * The lifetime of the data is the same as that of the @see read</td><td> </td><td class="right">     * The lifetime of the data is the same as that of the @see read</td></tr>
      <tr><td class="left">     * function above.</td><td> </td><td class="right">     * function above.</td></tr>
      <tr><td class="left">     */</td><td> </td><td class="right">     */</td></tr>
      <tr><td class="left">    apr_status_t (*readline)(serf_bucket_t *bucket, int acceptable,</td><td> </td><td class="right">    apr_status_t (*readline)(serf_bucket_t *bucket, int acceptable,</td></tr>
      <tr><td class="left">                             int *found,</td><td> </td><td class="right">                             int *found,</td></tr>
      <tr><td class="left">                             const char **data, apr_size_t *len);</td><td> </td><td class="right">                             const char **data, apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /**</td><td> </td><td class="right">    /**</td></tr>
      <tr><td class="left">     * Read a set of pointer/length pairs from the bucket.</td><td> </td><td class="right">     * Read a set of pointer/length pairs from the bucket.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-10" class="change" ><th><small>skipping to change at</small><a href="#part-10"><em> line 871<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-10"><em> line 1093<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">     * APR_EAGAIN will never be returned.</td><td> </td><td class="right">     * APR_EAGAIN will never be returned.</td></tr>
      <tr><td class="left">     */</td><td> </td><td class="right">     */</td></tr>
      <tr><td class="left">    apr_status_t (*peek)(serf_bucket_t *bucket,</td><td> </td><td class="right">    apr_status_t (*peek)(serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">                         const char **data, apr_size_t *len);</td><td> </td><td class="right">                         const char **data, apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /**</td><td> </td><td class="right">    /**</td></tr>
      <tr><td class="left">     * Destroy @a bucket, along with any associated resources.</td><td> </td><td class="right">     * Destroy @a bucket, along with any associated resources.</td></tr>
      <tr><td class="left">     */</td><td> </td><td class="right">     */</td></tr>
      <tr><td class="left">    void (*destroy)(serf_bucket_t *bucket);</td><td> </td><td class="right">    void (*destroy)(serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    <span class="insert">/* The following members are valid only if read_bucket equals to</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * serf_buckets_are_v2() (or in a future spec _v3, etc.). */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /* Real pointer to read_bucket() method when read_bucket is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * serf_buckets_are_v2().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * @since New in 1.4 / Buckets v2.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t * (*read_bucket_v2)(serf_bucket_t *bucket,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      const serf_bucket_type_t *type);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /* Returns length of remaining data to be read in @a bucket. Returns</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * SERF_LENGTH_UNKNOWN if length is unknown.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * @since New in 1.4 / Buckets v2.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_uint64_t (*get_remaining)(serf_bucket_t *bucket);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /* Provides a reference to a config object containing all configuration</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * values relevant for this bucket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * @since New in 1.4 / Buckets v2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_status_t (*set_config)(serf_bucket_t *bucket, serf_config_t *config</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">    /* ### apr buckets have 'copy', 'split', and 'setaside' functions.</td><td> </td><td class="right">    /* ### apr buckets have 'copy', 'split', and 'setaside' functions.</td></tr>
      <tr><td class="left">       ### not sure whether those will be needed in this bucket model.</td><td> </td><td class="right">       ### not sure whether those will be needed in this bucket model.</td></tr>
      <tr><td class="left">    */</td><td> </td><td class="right">    */</td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Should the use and lifecycle of buckets be tracked?</td><td> </td><td class="right"> * Should the use and lifecycle of buckets be tracked?</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * When tracking, the system will ensure several semantic requirements</td><td> </td><td class="right"> * When tracking, the system will ensure several semantic requirements</td></tr>
      <tr><td class="left"> * of bucket use:</td><td> </td><td class="right"> * of bucket use:</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-11" class="change" ><th><small>skipping to change at</small><a href="#part-11"><em> line 897<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-11"><em> line 1144<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *   - buckets should not be destroyed before they return APR_EOF unless</td><td> </td><td class="right"> *   - buckets should not be destroyed before they return APR_EOF unless</td></tr>
      <tr><td class="left"> *     the connection is closed for some reason.</td><td> </td><td class="right"> *     the connection is closed for some reason.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Undefine this symbol to avoid the tracking (and a performance gain).</td><td> </td><td class="right"> * Undefine this symbol to avoid the tracking (and a performance gain).</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ### we may want to examine when/how we provide this. should it always</td><td> </td><td class="right"> * ### we may want to examine when/how we provide this. should it always</td></tr>
      <tr><td class="left"> * ### be compiled in? and apps select it before including this header?</td><td> </td><td class="right"> * ### be compiled in? and apps select it before including this header?</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/* #define SERF_DEBUG_BUCKET_USE */</td><td> </td><td class="right">/* #define SERF_DEBUG_BUCKET_USE */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0025"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Predefined value for read_bucket vtable member to declare v2 buckets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * vtable.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t * serf_buckets_are_v2(serf_bucket_t *bucket,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    const serf_bucket_type_t *type);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Gets the serf bucket type of the bucket if the bucket implements at lea</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">st</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * buckets version, or if not a bucket type providing a default implementat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">const serf_bucket_type_t *serf_get_type(serf_bucket_t *bucket,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        int min_version);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Internal macros for tracking bucket use. */</td><td> </td><td class="right">/* Internal macros for tracking bucket use. */</td></tr>
      <tr><td class="left">#ifdef SERF_DEBUG_BUCKET_USE</td><td> </td><td class="right">#ifdef SERF_DEBUG_BUCKET_USE</td></tr>
      <tr><td class="left">#define SERF__RECREAD(b,s) serf_debug__record_read(b,s)</td><td> </td><td class="right">#define SERF__RECREAD(b,s) serf_debug__record_read(b,s)</td></tr>
      <tr><td class="left">#else</td><td> </td><td class="right">#else</td></tr>
      <tr><td class="left">#define SERF__RECREAD(b,s) (s)</td><td> </td><td class="right">#define SERF__RECREAD(b,s) (s)</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define serf_bucket_read(b,r,d,l) SERF__RECREAD(b, (b)-&gt;type-&gt;read(b,r,d,l)
)</td><td> </td><td class="right">#define serf_bucket_read(b,r,d,l) SERF__RECREAD(b, (b)-&gt;type-&gt;read(b,r,d,l)
)</td></tr>
      <tr><td class="left">#define serf_bucket_readline(b,a,f,d,l) \</td><td> </td><td class="right">#define serf_bucket_readline(b,a,f,d,l) \</td></tr>
      <tr><td class="left">    SERF__RECREAD(b, (b)-&gt;type-&gt;readline(b,a,f,d,l))</td><td> </td><td class="right">    SERF__RECREAD(b, (b)-&gt;type-&gt;readline(b,a,f,d,l))</td></tr>
      <tr><td class="left">#define serf_bucket_read_iovec(b,r,s,v,u) \</td><td> </td><td class="right">#define serf_bucket_read_iovec(b,r,s,v,u) \</td></tr>
      <tr><td class="left">    SERF__RECREAD(b, (b)-&gt;type-&gt;read_iovec(b,r,s,v,u))</td><td> </td><td class="right">    SERF__RECREAD(b, (b)-&gt;type-&gt;read_iovec(b,r,s,v,u))</td></tr>
      <tr><td class="left">#define serf_bucket_read_for_sendfile(b,r,h,f,o,l) \</td><td> </td><td class="right">#define serf_bucket_read_for_sendfile(b,r,h,f,o,l) \</td></tr>
      <tr><td class="left">    SERF__RECREAD(b, (b)-&gt;type-&gt;read_for_sendfile(b,r,h,f,o,l))</td><td> </td><td class="right">    SERF__RECREAD(b, (b)-&gt;type-&gt;read_for_sendfile(b,r,h,f,o,l))</td></tr>
      <tr><td class="left">#define serf_bucket_read_bucket(b,t) ((b)-&gt;type-&gt;read_bucket(b,t))</td><td> </td><td class="right">#define serf_bucket_read_bucket(b,t) ((b)-&gt;type-&gt;read_bucket(b,t))</td></tr>
      <tr><td class="left">#define serf_bucket_peek(b,d,l) ((b)-&gt;type-&gt;peek(b,d,l))</td><td> </td><td class="right">#define serf_bucket_peek(b,d,l) ((b)-&gt;type-&gt;peek(b,d,l))</td></tr>
      <tr><td class="left">#define serf_bucket_destroy(b) ((b)-&gt;type-&gt;destroy(b))</td><td> </td><td class="right">#define serf_bucket_destroy(b) ((b)-&gt;type-&gt;destroy(b))</td></tr>
      <tr id="diff0026"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define serf_bucket_get_remaining(b) (serf_get_type(b, 2)-&gt;get_remaining(b)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define serf_bucket_set_config(b,c) (serf_get_type(b, 2)-&gt;set_config(b, c))</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check whether a real error occurred. Note that bucket read functions</td><td> </td><td class="right"> * Check whether a real error occurred. Note that bucket read functions</td></tr>
      <tr><td class="left"> * can return EOF and EAGAIN as part of their "normal" operation, so they</td><td> </td><td class="right"> * can return EOF and EAGAIN as part of their "normal" operation, so they</td></tr>
      <tr><td class="left"> * should not be considered an error.</td><td> </td><td class="right"> * should not be considered an error.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_BUCKET_READ_ERROR(status) ((status) \</td><td> </td><td class="right">#define SERF_BUCKET_READ_ERROR(status) ((status) \</td></tr>
      <tr><td class="left">                                        &amp;&amp; !APR_STATUS_IS_EOF(status) \</td><td> </td><td class="right">                                        &amp;&amp; !APR_STATUS_IS_EOF(status) \</td></tr>
      <tr><td class="left">                                        &amp;&amp; !APR_STATUS_IS_EAGAIN(status) \</td><td> </td><td class="right">                                        &amp;&amp; !APR_STATUS_IS_EAGAIN(status) \</td></tr>
      <tr><td class="left">                                        &amp;&amp; (SERF_ERROR_WAIT_CONN != status)
)</td><td> </td><td class="right">                                        &amp;&amp; (SERF_ERROR_WAIT_CONN != status)
)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-12" class="change" ><th><small>skipping to change at</small><a href="#part-12"><em> line 942<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-12"><em> line 1207<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /** the allocator used for this bucket (needed at destroy time) */</td><td> </td><td class="right">    /** the allocator used for this bucket (needed at destroy time) */</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator;</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator;</td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Generic macro to construct "is TYPE" macros.</td><td> </td><td class="right"> * Generic macro to construct "is TYPE" macros.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_BUCKET_CHECK(b, btype) ((b)-&gt;type == &amp;serf_bucket_type_ ## bty
pe)</td><td> </td><td class="right">#define SERF_BUCKET_CHECK(b, btype) ((b)-&gt;type == &amp;serf_bucket_type_ ## bty
pe)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0027"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @} */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Notification callback for a block that was not returned to the bucket</td><td> </td><td class="right"> * Notification callback for a block that was not returned to the bucket</td></tr>
      <tr><td class="left"> * allocator when its pool was destroyed.</td><td> </td><td class="right"> * allocator when its pool was destroyed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The block of memory is given by @a block. The baton provided when the</td><td> </td><td class="right"> * The block of memory is given by @a block. The baton provided when the</td></tr>
      <tr><td class="left"> * allocator was constructed is passed as @a unfreed_baton.</td><td> </td><td class="right"> * allocator was constructed is passed as @a unfreed_baton.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef void (*serf_unfreed_func_t)(</td><td> </td><td class="right">typedef void (*serf_unfreed_func_t)(</td></tr>
      <tr><td class="left">    void *unfreed_baton,</td><td> </td><td class="right">    void *unfreed_baton,</td></tr>
      <tr><td class="left">    void *block);</td><td> </td><td class="right">    void *block);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-13" class="change" ><th><small>skipping to change at</small><a href="#part-13"><em> line 1000<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-13"><em> line 1267<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * Since it is entirely possible for a line to be broken by APR_EAGAIN,</td><td> </td><td class="right"> * Since it is entirely possible for a line to be broken by APR_EAGAIN,</td></tr>
      <tr><td class="left"> * this structure can be used to accumulate the data until a complete line</td><td> </td><td class="right"> * this structure can be used to accumulate the data until a complete line</td></tr>
      <tr><td class="left"> * has been read from a bucket.</td><td> </td><td class="right"> * has been read from a bucket.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* This limit applies to the line buffer functions. If an application needs</td><td> </td><td class="right">/* This limit applies to the line buffer functions. If an application needs</td></tr>
      <tr><td class="left"> * longer lines, then they will need to manually handle line buffering.</td><td> </td><td class="right"> * longer lines, then they will need to manually handle line buffering.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_LINEBUF_LIMIT 8000</td><td> </td><td class="right">#define SERF_LINEBUF_LIMIT 8000</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0028"></tr>
      <tr><td class="lblock">typedef struct {</td><td> </td><td class="rblock">typedef struct <span class="insert">serf_linebuf_t </span>{</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /* Current state of the buffer. */</td><td> </td><td class="right">    /* Current state of the buffer. */</td></tr>
      <tr><td class="left">    enum {</td><td> </td><td class="right">    enum {</td></tr>
      <tr><td class="left">        SERF_LINEBUF_EMPTY,</td><td> </td><td class="right">        SERF_LINEBUF_EMPTY,</td></tr>
      <tr><td class="left">        SERF_LINEBUF_READY,</td><td> </td><td class="right">        SERF_LINEBUF_READY,</td></tr>
      <tr><td class="left">        SERF_LINEBUF_PARTIAL,</td><td> </td><td class="right">        SERF_LINEBUF_PARTIAL,</td></tr>
      <tr><td class="left">        SERF_LINEBUF_CRLF_SPLIT</td><td> </td><td class="right">        SERF_LINEBUF_CRLF_SPLIT</td></tr>
      <tr><td class="left">    } state;</td><td> </td><td class="right">    } state;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /* How much of the buffer have we used? */</td><td> </td><td class="right">    /* How much of the buffer have we used? */</td></tr>
      <tr><td class="left">    apr_size_t used;</td><td> </td><td class="right">    apr_size_t used;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0029"></tr>
      <tr><td class="lblock">    /* The line is read into this buffer, minus <span class="delete">CR/LF */</span></td><td> </td><td class="rblock">    /* The line is read into this buffer, minus <span class="insert">CR/LF.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * NOTE: Before serf 2.0 buffer IS NOT NUL terminated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * and @a used should be used to find line length.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * Since serf 2.0 buffer is always NUL terminated.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     **/</span></td></tr>
      <tr><td class="left">    char line[SERF_LINEBUF_LIMIT];</td><td> </td><td class="right">    char line[SERF_LINEBUF_LIMIT];</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} serf_linebuf_t;</td><td> </td><td class="right">} serf_linebuf_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Initialize the @a linebuf structure.</td><td> </td><td class="right"> * Initialize the @a linebuf structure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void serf_linebuf_init(serf_linebuf_t *linebuf);</td><td> </td><td class="right">void serf_linebuf_init(serf_linebuf_t *linebuf);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-14" class="change" ><th><small>skipping to change at</small><a href="#part-14"><em> line 1036<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-14"><em> line 1309<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * acceptable for this fetch.</td><td> </td><td class="right"> * acceptable for this fetch.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ### we should return a data/len pair so that we can avoid a copy,</td><td> </td><td class="right"> * ### we should return a data/len pair so that we can avoid a copy,</td></tr>
      <tr><td class="left"> * ### rather than having callers look into our state and line buffer.</td><td> </td><td class="right"> * ### rather than having callers look into our state and line buffer.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_linebuf_fetch(</td><td> </td><td class="right">apr_status_t serf_linebuf_fetch(</td></tr>
      <tr><td class="left">    serf_linebuf_t *linebuf,</td><td> </td><td class="right">    serf_linebuf_t *linebuf,</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    int acceptable);</td><td> </td><td class="right">    int acceptable);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0030"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/*** Configuration store declarations ***/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef const apr_uint32_t serf_config_key_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The left-most byte of the int32 key holds the category (bit flags).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   The other bytes are a number representing the key.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Serf will not use the second byte for its own keys, so applications can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   use this byte to define custom keys.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum serf_config_categories_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    SERF_CONFIG_PER_CONTEXT    = 0x10000000,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    SERF_CONFIG_PER_HOST       = 0x20000000,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    SERF_CONFIG_PER_CONNECTION = 0x40000000,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} serf_config_categories_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_CONFIG_HOST_NAME       (SERF_CONFIG_PER_HOST | 0x000001)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_CONFIG_HOST_PORT       (SERF_CONFIG_PER_HOST | 0x000002)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_CONFIG_CONN_LOCALIP    (SERF_CONFIG_PER_CONNECTION | 0x000001)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_CONFIG_CONN_REMOTEIP   (SERF_CONFIG_PER_CONNECTION | 0x000002)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_CONFIG_CONN_PIPELINING (SERF_CONFIG_PER_CONNECTION | 0x000003)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_CONFIG_CTX_LOGBATON    (SERF_CONFIG_PER_CONTEXT | 0x000001)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Configuration values stored in the configuration store:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Category     Key          Value Type</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   --------     ---          ----------</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Context      logbaton     log_baton_t *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Context      proxyauthn   apr_hash_t * (not implemented)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Connection   localip      const char *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Connection   remoteip     const char *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Host         hostname     const char *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Host         hostport     const char *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Host         authn        apr_hash_t * (not implemented)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Set a value of type const char * for configuration item CATEGORY+KEY.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_config_set_string(serf_config_t *config,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    serf_config_key_t key,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    const char *value);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Copy a value of type const char * and set it for configuration item</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   CATEGORY+KEY.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_config_set_stringc(serf_config_t *config,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                     serf_config_key_t key,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                     const char *value);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Set a value of generic type for configuration item CATEGORY+KEY.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   See @a serf_set_config_string for COPY_FLAGS description.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_config_set_stringf(serf_config_t *config,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                     serf_config_key_t key,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                     apr_pool_t *scratch_pool,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                     const char *fmt, ...);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Set a value of generic type for configuration item CATEGORY+KEY.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   See @a serf_set_config_string for COPY_FLAGS description.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_config_set_object(serf_config_t *config,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    serf_config_key_t key,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    void *value);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Get the value for configuration item CATEGORY+KEY. The value's type will</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   be fixed, see the above table.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Returns APR_EINVAL when getting a key from a category that this config</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   object doesn't contain, APR_SUCCESS otherwise.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_config_get_string(serf_config_t *config,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    serf_config_key_t key,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    const char **value);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_config_get_object(serf_config_t *config,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    serf_config_key_t key,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    void **value);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Remove the value for configuration item CATEGORY+KEY from the configurat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   store.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_config_remove_value(serf_config_t *config,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      serf_config_key_t key);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/*** Serf logging API ***/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Ordered list of log levels, more detailed log levels include less</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   detailed levels. (e.g. level DEBUG also logs ERROR, WARNING &amp; INFO messa</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ges).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOG_ERROR   0x0001</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOG_WARNING 0x0002</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOG_INFO    0x0004</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOG_DEBUG   0x0008</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOG_NONE    0x0000</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* List of components, used as a mask. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_ALL_MSG  0xFFFF /* All components, including message</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        content */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_RAWMSG   0x0100 /* logs requests and responses directl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y on</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        the socket layer. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_SSLMSG   0x0200 /* logs decrypted requests and respons</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">es. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_ALL      0x00FF /* All components, no message content </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_SSL      0x0001 /* The SSL component */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_AUTHN    0x0002 /* Authentication components */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_CONN     0x0004 /* Connection-related events */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_COMPR    0x0008 /* The compression (deflate) component</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_PROTOCOL 0x0010 /* The protocol components */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOGCOMP_NONE     0x0000</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_log_output_t serf_log_output_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_log_layout_t serf_log_layout_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The default log layout. It's format is:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   [TIMESTAMP] [LOG LEVEL] [l:LOCALIP:PORT r:REMOTEIP:PORT] FILENAME MESSAG</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">E</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_LOG_DEFAULT_LAYOUT ((serf_log_layout_t *)NULL)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* TODO: it's not yet possible to define custom layouts */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Create a stream output for log info. This can be used with one of the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   standard streams stderr or stdout.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   LAYOUT should be SERF_LOG_DEFAULT_LAYOUT (there's no alternative for now</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   The lifetime of POOL should be atleast the same as that of CTX, but it c</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">an</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   be used by multiple contexts. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_logging_create_stream_output(serf_log_output_t **output,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               apr_uint32_t level,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               apr_uint32_t comp_mask,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               serf_log_layout_t *layout,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               FILE *fp,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define an output handler for a log level and a (set of) log component(s)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   OUTPUT is the object returned by one of the serf_logging_create_XXX_outp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ut</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   factory functions. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_logging_add_output(serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                     const serf_log_output_t *output);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/*** Connection and protocol API v2 ***/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#if 0</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ### docco.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_connection_switch_protocol(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_connection_t *conn,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_protocol_t *proto</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /* ### other params?  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    );</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ### docco.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_queue_item_t serf_queue_item_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Present a response to the application.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Called when a response has been processed by the current protocol (to an</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * extent necessary) and is ready for the application to handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note: @a request may be NULL if this response is server-pushed rather th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">an</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *       specifically requested.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_begin_response_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /* ### args not settled  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void **handler_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_request_t *request,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *response,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *scratch_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ### better name?  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_handler_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /* ### args not settled  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *handler_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *response,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *scratch_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct serf_protocol_type_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /** Name of this protocol type.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *name;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /** Vtable version.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int version;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_PROTOCOL_TYPE_VERSION 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * When a pending request reaches the front of the queue, then it becom</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">es</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * "active". This callback is used to build/provide the protocol-specif</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ic</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * request bucket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * ### more docco</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_status_t (*serf_request_activate_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        serf_bucket_t **request_bkt,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        serf_queue_item_t *request_qi,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        void *request_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        serf_bucket_alloc_t *request_bktalloc,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        apr_pool_t *scratch_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * Construct a protocol parsing bucket, for passing to the process_data</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * vtable entry.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * When data arrives on the connection, and a parser is not already</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * processing the connection's data, then build a new bucket to parse</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * this incoming data (according to the protocol).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t * (*build_parser)(serf_protocol_t *proto,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    apr_pool_t *scratch_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * The protocol should parse all available response data, per the proto</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">col.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * This is called when data has become available to the parser. The pro</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tocol</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * should read all available data before returning.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_status_t (*process_data)(serf_protocol_t *proto,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                 serf_bucket_t *parser,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                 apr_pool_t *scratch_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">};</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Activate an HTTP request when it reaches the front of the queue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ### more docco</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_http_activate_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t **body_bkt,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *request_bkt,  /* type REQUEST  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_queue_item_t *request_qi,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *request_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *request_bktalloc,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *scratch_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Create a new connection and associated HTTP protocol parser.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The new connection/protocol will be associated with @a ctx. It will be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * opened once a request is placed into its outgoing queue. The connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * will use @a hostname and @a port for the origin server. If</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @a proxy_hostname is not NULL, then all requests will go through the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * proxy specified by @a proxy_hostname and @a proxy_port.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * DNS lookups for @a hostname and @a proxy_hostname will be performed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * when the connection first opened, then cached in case the connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ever needs to be re-opened.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * When a queued request reaches the front of the queue, and is ready for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * delivery, then @a activate_cb will be called to prepare the request.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @a authn_types specifies the types of authentication allowed on this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * connection. Normally, it should be SERF_AUTHN_ALL. When authentication</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * credentials are required (for the origin server or the proxy), then</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @a creds_cb will be called with @a app_baton.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * When the connection is closed (upon request or because of an error),</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * then @a closed_cb will be called with @a app_baton.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The connection and protocol paresr will be allocated in @a result_pool.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function will use @a scratch_pool for temporary allocations.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_http_protocol_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_protocol_t **proto,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *hostname,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int port,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *proxy_hostname,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int proxy_port,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int authn_types,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_http_activate_t activate_cb,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /* ### do we need different params for CREDS_CB and CLOSED_CB ?  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_credentials_callback_t creds_cb,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_connection_closed_t closed_cb,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *app_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *result_pool,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *scratch_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ### docco. create http proto parser with an encrypted connection.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_https_protocol_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_protocol_t **proto,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *hostname,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int port,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /* ### client certs, credential validation callbacks, etc  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_connection_closed_t closed,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *closed_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *result_pool,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *scratch_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ### docco. queue up an http request.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_queue_item_t *serf_http_request_queue(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_protocol_t *proto,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int priority,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *request_baton);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ### rationalize against "serf connections and request" group above</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @defgroup serf connections</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @ingroup serf</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct serf_connection_type_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /** Name of this connection type.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *name;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /** Vtable version.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int version;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_CONNECTION_TYPE_VERSION 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * Initiate a connection to the server.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * ### docco. note async. note that request(s) may be queued.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * ### can we somehow defer the SSL tunnel's CONNECT to the higher</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * ### layer? then have the HTTP protocol layer wrap a CONN_PLAIN</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * ### into a CONN_TLS connection once the tunnel is established?</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_status_t (*connect)(serf_connection_t *conn);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * Returns a bucket for reading from this connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * This bucket remains constant for the lifetime of the connection. It </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">has</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * built-in BARRIER bucket protection, so it can safely be "destroyed"</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * without problem (and a later call to this vtable function will retur</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * the same bucket again).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * For all intents and purposes, this bucket is borrowed by the caller.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * This bucket effectively maps to the underlying socket, or possibly t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * a decrypting bucket layered over the socket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t * (*get_read_bucket)(serf_connection_t *conn);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    /**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * Write some data into into the connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * Attempt to write a number of iovecs into the connection. The number </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * vectors *completely* written will be returned in @a vecs_written. If</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * equals @a vecs_size, then @a last_written will be set to 0. If it is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> less</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * (not all iovecs were written), then the amount written from the next</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * incompletely written iovec is returned in @a last_written.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * In other words, the first byte of unwritten content is located at:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * &lt;pre&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *   first = vecs[vecs_written][last_written];</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * &lt;/pre&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * If all bytes are written, then APR_SUCCESS is returned. If only a po</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rtion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     * was written, then APR_EAGAIN will be returned.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_status_t (*writev)(serf_connection_t *conn,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                           int vecs_size, struct iovec *vecs,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                           int *vecs_written, apr_size_t *last_written);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">};</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif /* Connection and protocol API v2 */</span></td></tr>
      <tr><td class="left">/** @} */</td><td> </td><td class="right">/** @} */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Internal functions for bucket use and lifecycle tracking */</td><td> </td><td class="right">/* Internal functions for bucket use and lifecycle tracking */</td></tr>
      <tr><td class="left">apr_status_t serf_debug__record_read(</td><td> </td><td class="right">apr_status_t serf_debug__record_read(</td></tr>
      <tr><td class="left">    const serf_bucket_t *bucket,</td><td> </td><td class="right">    const serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    apr_status_t status);</td><td> </td><td class="right">    apr_status_t status);</td></tr>
      <tr><td class="left">void serf_debug__entered_loop(</td><td> </td><td class="right">void serf_debug__entered_loop(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left">void serf_debug__closed_conn(</td><td> </td><td class="right">void serf_debug__closed_conn(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left">void serf_debug__bucket_destroy(</td><td> </td><td class="right">void serf_debug__bucket_destroy(</td></tr>
      <tr><td class="left">    const serf_bucket_t *bucket);</td><td> </td><td class="right">    const serf_bucket_t *bucket);</td></tr>
      <tr><td class="left">void serf_debug__bucket_alloc_check(</td><td> </td><td class="right">void serf_debug__bucket_alloc_check(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Version info */</td><td> </td><td class="right">/* Version info */</td></tr>
      <tr id="diff0031"></tr>
      <tr><td class="lblock">#define SERF_MAJOR_VERSION <span class="delete">1</span></td><td> </td><td class="rblock">#define SERF_MAJOR_VERSION <span class="insert">2</span></td></tr>
      <tr><td class="lblock">#define SERF_MINOR_VERSION <span class="delete">3</span></td><td> </td><td class="rblock">#define SERF_MINOR_VERSION <span class="insert">0</span></td></tr>
      <tr><td class="lblock">#define SERF_PATCH_VERSION <span class="delete">9</span></td><td> </td><td class="rblock">#define SERF_PATCH_VERSION <span class="insert">0</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Version number string */</td><td> </td><td class="right">/* Version number string */</td></tr>
      <tr><td class="left">#define SERF_VERSION_STRING APR_STRINGIFY(SERF_MAJOR_VERSION) "." \</td><td> </td><td class="right">#define SERF_VERSION_STRING APR_STRINGIFY(SERF_MAJOR_VERSION) "." \</td></tr>
      <tr><td class="left">                            APR_STRINGIFY(SERF_MINOR_VERSION) "." \</td><td> </td><td class="right">                            APR_STRINGIFY(SERF_MINOR_VERSION) "." \</td></tr>
      <tr><td class="left">                            APR_STRINGIFY(SERF_PATCH_VERSION)</td><td> </td><td class="right">                            APR_STRINGIFY(SERF_PATCH_VERSION)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check at compile time if the Serf version is at least a certain</td><td> </td><td class="right"> * Check at compile time if the Serf version is at least a certain</td></tr>
      <tr><td class="left"> * level.</td><td> </td><td class="right"> * level.</td></tr>
      <tr><td class="left"> * @param major The major version component of the version checked</td><td> </td><td class="right"> * @param major The major version component of the version checked</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 31 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>16 lines changed or deleted</i></th><th><i> </i></th><th><i>692 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;serf_bucket_types.h (1.3.9)&nbsp;</th><th> </th><th>&nbsp;serf_bucket_types.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 62<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 62<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Send a Content-Length header with @a len. The @a body bucket should</td><td> </td><td class="right">/* Send a Content-Length header with @a len. The @a body bucket should</td></tr>
      <tr><td class="left">   contain precisely that much data.  */</td><td> </td><td class="right">   contain precisely that much data.  */</td></tr>
      <tr><td class="left">void serf_bucket_request_set_CL(</td><td> </td><td class="right">void serf_bucket_request_set_CL(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    apr_int64_t len);</td><td> </td><td class="right">    apr_int64_t len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_request_get_headers(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_request_get_headers(</td></tr>
      <tr><td class="left">    serf_bucket_t *request);</td><td> </td><td class="right">    serf_bucket_t *request);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Transform @a bucket in-place into a request bucket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * It is callers responsibility to free resources held by the original</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * bucket */</span></td></tr>
      <tr><td class="left">void serf_bucket_request_become(</td><td> </td><td class="right">void serf_bucket_request_become(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    const char *method,</td><td> </td><td class="right">    const char *method,</td></tr>
      <tr><td class="left">    const char *uri,</td><td> </td><td class="right">    const char *uri,</td></tr>
      <tr><td class="left">    serf_bucket_t *body);</td><td> </td><td class="right">    serf_bucket_t *body);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Sets the root url of the remote host. If this request contains a relativ
e</td><td> </td><td class="right"> * Sets the root url of the remote host. If this request contains a relativ
e</td></tr>
      <tr><td class="left"> * url, it will be prefixed with the root url to form an absolute url.</td><td> </td><td class="right"> * url, it will be prefixed with the root url to form an absolute url.</td></tr>
      <tr><td class="left"> * @a bucket is the request bucket. @a root_url is the absolute url of the</td><td> </td><td class="right"> * @a bucket is the request bucket. @a root_url is the absolute url of the</td></tr>
      <tr><td class="left"> * root of the remote host, without the closing '/'.</td><td> </td><td class="right"> * root of the remote host, without the closing '/'.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void serf_bucket_request_set_root(</td><td> </td><td class="right">void serf_bucket_request_set_root(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    const char *root_url);</td><td> </td><td class="right">    const char *root_url);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_incoming_request;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_BUCKET_IS_INCOMING_REQUEST(b)                              \</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                SERF_BUCKET_CHECK((b), incoming_request)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf_bucket_incoming_request_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      serf_bucket_t *body,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* All output arguments optional. Waits for the request line to have arrive</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   with the normal read responses. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ### Add RESULT_POOL argument? */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_bucket_incoming_request_read(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      serf_bucket_t **headers,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      const char **method,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      const char **path,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      int *http_version,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      serf_bucket_t *request);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_bucket_incoming_request_wait_for_headers(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      serf_bucket_t *response);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ==================================================================== */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">extern const serf_bucket_type_t serf_bucket_type_response;</td><td> </td><td class="right">extern const serf_bucket_type_t serf_bucket_type_response;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_RESPONSE(b) SERF_BUCKET_CHECK((b), response)</td><td> </td><td class="right">#define SERF_BUCKET_IS_RESPONSE(b) SERF_BUCKET_CHECK((b), response)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_response_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_response_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define SERF_HTTP_VERSION(major, minor)  ((major) * 1000 + (minor))</td><td> </td><td class="right">#define SERF_HTTP_VERSION(major, minor)  ((major) * 1000 + (minor))</td></tr>
      <tr><td class="left">#define SERF_HTTP_11 SERF_HTTP_VERSION(1, 1)</td><td> </td><td class="right">#define SERF_HTTP_11 SERF_HTTP_VERSION(1, 1)</td></tr>
      <tr><td class="left">#define SERF_HTTP_10 SERF_HTTP_VERSION(1, 0)</td><td> </td><td class="right">#define SERF_HTTP_10 SERF_HTTP_VERSION(1, 0)</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_HTTP_20 SERF_HTTP_VERSION(2, 0)</span></td></tr>
      <tr><td class="left">#define SERF_HTTP_VERSION_MAJOR(shv) ((int)shv / 1000)</td><td> </td><td class="right">#define SERF_HTTP_VERSION_MAJOR(shv) ((int)shv / 1000)</td></tr>
      <tr><td class="left">#define SERF_HTTP_VERSION_MINOR(shv) ((int)shv % 1000)</td><td> </td><td class="right">#define SERF_HTTP_VERSION_MINOR(shv) ((int)shv % 1000)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">typedef struct {</td><td> </td><td class="rblock">typedef struct <span class="insert">serf_status_line </span>{</td></tr>
      <tr><td class="left">    int version;</td><td> </td><td class="right">    int version;</td></tr>
      <tr><td class="left">    int code;</td><td> </td><td class="right">    int code;</td></tr>
      <tr><td class="left">    const char *reason;</td><td> </td><td class="right">    const char *reason;</td></tr>
      <tr><td class="left">} serf_status_line;</td><td> </td><td class="right">} serf_status_line;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the Status-Line information, if available. This function</td><td> </td><td class="right"> * Return the Status-Line information, if available. This function</td></tr>
      <tr><td class="left"> * works like other bucket read functions: it may return APR_EAGAIN or</td><td> </td><td class="right"> * works like other bucket read functions: it may return APR_EAGAIN or</td></tr>
      <tr><td class="left"> * APR_EOF to signal the state of the bucket for reading. A return</td><td> </td><td class="right"> * APR_EOF to signal the state of the bucket for reading. A return</td></tr>
      <tr><td class="left"> * value of APR_SUCCESS will always indicate that status line</td><td> </td><td class="right"> * value of APR_SUCCESS will always indicate that status line</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 122<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 151<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Wait for the HTTP headers to be processed for a @a response.</td><td> </td><td class="right"> * Wait for the HTTP headers to be processed for a @a response.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If the headers are available, APR_SUCCESS is returned.</td><td> </td><td class="right"> * If the headers are available, APR_SUCCESS is returned.</td></tr>
      <tr><td class="left"> * If the headers aren't available, APR_EAGAIN is returned.</td><td> </td><td class="right"> * If the headers aren't available, APR_EAGAIN is returned.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_bucket_response_wait_for_headers(</td><td> </td><td class="right">apr_status_t serf_bucket_response_wait_for_headers(</td></tr>
      <tr><td class="left">    serf_bucket_t *response);</td><td> </td><td class="right">    serf_bucket_t *response);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Wait for the first HTTP headers to be processed for a @a response.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * If 1XX informational responses are received before the actual headers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * this function will return APR_SUCCESS as soon as such a set is processed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * while serf_bucket_response_wait_for_headers() will wait until the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * actual headers to be available.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * If @a wait_for_next is TRUE, the function will wait for the next set</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * of informational header instead of returning success for the first set.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_bucket_response_wait_for_some_headers(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *response,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int wait_for_next);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Get the headers bucket for @a response.</td><td> </td><td class="right"> * Get the headers bucket for @a response.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_response_get_headers(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_response_get_headers(</td></tr>
      <tr><td class="left">    serf_bucket_t *response);</td><td> </td><td class="right">    serf_bucket_t *response);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Advise the response @a bucket that this was from a HEAD request and</td><td> </td><td class="right"> * Advise the response @a bucket that this was from a HEAD request and</td></tr>
      <tr><td class="left"> * that it should not expect to see a response body.</td><td> </td><td class="right"> * that it should not expect to see a response body.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void serf_bucket_response_set_head(</td><td> </td><td class="right">void serf_bucket_response_set_head(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket);</td><td> </td><td class="right">    serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Ask the response @a bucket, to decode content based on the value of the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * 'Content- Encoding' header, or not. The default setting of a response</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * bucket is to decode when the header is found.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void serf_bucket_response_decode_content(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *bucket,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int decode);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">extern const serf_bucket_type_t serf_bucket_type_response_body;</td><td> </td><td class="right">extern const serf_bucket_type_t serf_bucket_type_response_body;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_RESPONSE_BODY(b) SERF_BUCKET_CHECK((b), response_bod
y)</td><td> </td><td class="right">#define SERF_BUCKET_IS_RESPONSE_BODY(b) SERF_BUCKET_CHECK((b), response_bod
y)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_response_body_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_response_body_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    apr_uint64_t limit,</td><td> </td><td class="right">    apr_uint64_t limit,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_outgoing_response;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_BUCKET_IS_OUTGOING_RESPONSE(b)         \</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                SERF_BUCKET_CHECK((b), outgoing_response)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf_bucket_outgoing_response_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *body,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int status,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *reason,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int http_version,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf_bucket_outgoing_response_get_headers(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *outgoing_response);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void serf_bucket_outgoing_response_prepare(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *outgoing_response,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int http_version,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int allow_chunking);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ==================================================================== */</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">extern const serf_bucket_type_t serf_bucket_type_bwtp_frame;</td><td> </td><td class="right">extern const serf_bucket_type_t serf_bucket_type_bwtp_frame;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_BWTP_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_frame)</td><td> </td><td class="right">#define SERF_BUCKET_IS_BWTP_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_frame)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">extern const serf_bucket_type_t serf_bucket_type_bwtp_incoming_frame;</td><td> </td><td class="right">extern const serf_bucket_type_t serf_bucket_type_bwtp_incoming_frame;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_BWTP_INCOMING_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_i
ncoming_frame)</td><td> </td><td class="right">#define SERF_BUCKET_IS_BWTP_INCOMING_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_i
ncoming_frame)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">int serf_bucket_bwtp_frame_get_channel(</td><td> </td><td class="right">int serf_bucket_bwtp_frame_get_channel(</td></tr>
      <tr><td class="left">    serf_bucket_t *hdr);</td><td> </td><td class="right">    serf_bucket_t *hdr);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 209<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 288<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/** serf_bucket_aggregate_cleanup will instantly destroy all buckets in</td><td> </td><td class="right">/** serf_bucket_aggregate_cleanup will instantly destroy all buckets in</td></tr>
      <tr><td class="left">    the aggregate bucket that have been read completely. Whereas normally,</td><td> </td><td class="right">    the aggregate bucket that have been read completely. Whereas normally,</td></tr>
      <tr><td class="left">    these buckets are destroyed on every read operation. */</td><td> </td><td class="right">    these buckets are destroyed on every read operation. */</td></tr>
      <tr><td class="left">void serf_bucket_aggregate_cleanup(</td><td> </td><td class="right">void serf_bucket_aggregate_cleanup(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_aggregate_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_aggregate_create(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"><span class="delete">/* Creates a stream bucket.</span></td><td> </td><td class="rblock">/** Transform @a bucket in-place into an aggregate bucket.</td></tr>
      <tr><td class="lblock"><span class="delete">   A stream bucket is like an aggregate bucket, but:</span></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"><span class="delete">   - it doesn't destroy its child buckets on cleanup</span></td><td> </td><td class="rblock"><span class="insert"> * It is callers responsibility to free resources held by the original</span></td></tr>
      <tr><td class="lblock"><span class="delete">   - one can always keep adding child buckets, the handler FN should return</span></td><td> </td><td class="rblock"><span class="insert"> * bucket</span> */</td></tr>
      <tr><td class="lblock"><span class="delete">     APR_EOF when no more buckets will be added.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">  Note: keep this factory function internal for now. If it turns out this</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">  bucket type is useful outside serf, we should make it an actual separate</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">  type.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">  */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">serf_bucket_t *serf__bucket_stream_create(</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">    serf_bucket_alloc_t *allocator,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">    serf_bucket_aggregate_eof_t fn,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">    void *baton);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">/** Transform @a bucket in-place into an aggregate bucket. */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">void serf_bucket_aggregate_become(</td><td> </td><td class="right">void serf_bucket_aggregate_become(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket);</td><td> </td><td class="right">    serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">void serf_bucket_aggregate_prepend(</td><td> </td><td class="right">void serf_bucket_aggregate_prepend(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    serf_bucket_t *prepend_bucket);</td><td> </td><td class="right">    serf_bucket_t *prepend_bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">void serf_bucket_aggregate_append(</td><td> </td><td class="right">void serf_bucket_aggregate_append(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    serf_bucket_t *append_bucket);</td><td> </td><td class="right">    serf_bucket_t *append_bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 318<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 385<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * Equivalent to serf_bucket_simple_create, except that the bucket assumes</td><td> </td><td class="right"> * Equivalent to serf_bucket_simple_create, except that the bucket assumes</td></tr>
      <tr><td class="left"> * responsibility for freeing the data on this allocator without making</td><td> </td><td class="right"> * responsibility for freeing the data on this allocator without making</td></tr>
      <tr><td class="left"> * a copy.  It is assumed that data was created by a call from allocator.</td><td> </td><td class="right"> * a copy.  It is assumed that data was created by a call from allocator.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_simple_own_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_simple_own_create(</td></tr>
      <tr><td class="left">    const char *data,</td><td> </td><td class="right">    const char *data,</td></tr>
      <tr><td class="left">    apr_size_t len,</td><td> </td><td class="right">    apr_size_t len,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define SERF_BUCKET_SIMPLE_STRING(s,a) \</td><td> </td><td class="right">#define SERF_BUCKET_SIMPLE_STRING(s,a) \</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock">    serf_bucket_simple_create(s, strlen(s), NULL, NULL, a)<span class="delete">;</span></td><td> </td><td class="rblock">    serf_bucket_simple_create(s, strlen(s), NULL, NULL, a)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define SERF_BUCKET_SIMPLE_STRING_LEN(s,l,a) \</td><td> </td><td class="right">#define SERF_BUCKET_SIMPLE_STRING_LEN(s,l,a) \</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock">    serf_bucket_simple_create(s, l, NULL, NULL, a)<span class="delete">;</span></td><td> </td><td class="rblock">    serf_bucket_simple_create(s, l, NULL, NULL, a)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Note: apr_mmap_t is always defined, but if APR doesn't have mmaps, then</td><td> </td><td class="right">/* Note: apr_mmap_t is always defined, but if APR doesn't have mmaps, then</td></tr>
      <tr><td class="left">   the caller can never create an apr_mmap_t to pass to this function. */</td><td> </td><td class="right">   the caller can never create an apr_mmap_t to pass to this function. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">extern const serf_bucket_type_t serf_bucket_type_mmap;</td><td> </td><td class="right">extern const serf_bucket_type_t serf_bucket_type_mmap;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_MMAP(b) SERF_BUCKET_CHECK((b), mmap)</td><td> </td><td class="right">#define SERF_BUCKET_IS_MMAP(b) SERF_BUCKET_CHECK((b), mmap)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_mmap_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_mmap_create(</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 465<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 532<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_DEFLATE(b) SERF_BUCKET_CHECK((b), deflate)</td><td> </td><td class="right">#define SERF_BUCKET_IS_DEFLATE(b) SERF_BUCKET_CHECK((b), deflate)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define SERF_DEFLATE_GZIP 0</td><td> </td><td class="right">#define SERF_DEFLATE_GZIP 0</td></tr>
      <tr><td class="left">#define SERF_DEFLATE_DEFLATE 1</td><td> </td><td class="right">#define SERF_DEFLATE_DEFLATE 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_deflate_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_deflate_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator,</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator,</td></tr>
      <tr><td class="left">    int format);</td><td> </td><td class="right">    int format);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf_bucket_deflate_compress_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *stream,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int memlevel,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int format,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">extern const serf_bucket_type_t serf_bucket_type_limit;</td><td> </td><td class="right">extern const serf_bucket_type_t serf_bucket_type_limit;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_LIMIT(b) SERF_BUCKET_CHECK((b), limit)</td><td> </td><td class="right">#define SERF_BUCKET_IS_LIMIT(b) SERF_BUCKET_CHECK((b), limit)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_limit_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_limit_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    apr_uint64_t limit,</td><td> </td><td class="right">    apr_uint64_t limit,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock">#define SERF_SSL_CERT_NOTYETVALID       <span class="delete">1</span></td><td> </td><td class="rblock">#define SERF_SSL_CERT_NOTYETVALID       <span class="insert">0x0001</span></td></tr>
      <tr><td class="lblock">#define SERF_SSL_CERT_EXPIRED           <span class="delete">2</span></td><td> </td><td class="rblock">#define SERF_SSL_CERT_EXPIRED           <span class="insert">0x0002</span></td></tr>
      <tr><td class="lblock">#define SERF_SSL_CERT_UNKNOWNCA         <span class="delete">4</span></td><td> </td><td class="rblock">#define SERF_SSL_CERT_UNKNOWNCA         <span class="insert">0x0004</span></td></tr>
      <tr><td class="lblock">#define SERF_SSL_CERT_SELF_SIGNED       <span class="delete">8</span></td><td> </td><td class="rblock">#define SERF_SSL_CERT_SELF_SIGNED       <span class="insert">0x0008</span></td></tr>
      <tr><td class="lblock">#define SERF_SSL_CERT_UNKNOWN_FAILURE  <span class="delete">16</span></td><td> </td><td class="rblock">#define SERF_SSL_CERT_UNKNOWN_FAILURE   <span class="insert">0x0010</span></td></tr>
      <tr><td class="lblock">#define SERF_SSL_CERT_REVOKED          <span class="delete">32</span></td><td> </td><td class="rblock">#define SERF_SSL_CERT_REVOKED           <span class="insert">0x0020</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_SSL_CERT_UNABLE_TO_GET_CRL 0x0040</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_SSL_CERT_INVALID_HOST      0x0080</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_SSL_OCSP_RESPONDER_TRYLATER        0x0100</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_SSL_OCSP_RESPONDER_ERROR           0x0200</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_SSL_OCSP_RESPONDER_UNKNOWN_FAILURE 0x0400</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">extern const serf_bucket_type_t serf_bucket_type_ssl_encrypt;</td><td> </td><td class="right">extern const serf_bucket_type_t serf_bucket_type_ssl_encrypt;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_SSL_ENCRYPT(b) SERF_BUCKET_CHECK((b), ssl_encrypt)</td><td> </td><td class="right">#define SERF_BUCKET_IS_SSL_ENCRYPT(b) SERF_BUCKET_CHECK((b), ssl_encrypt)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct serf_ssl_context_t serf_ssl_context_t;</td><td> </td><td class="right">typedef struct serf_ssl_context_t serf_ssl_context_t;</td></tr>
      <tr><td class="left">typedef struct serf_ssl_certificate_t serf_ssl_certificate_t;</td><td> </td><td class="right">typedef struct serf_ssl_certificate_t serf_ssl_certificate_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef apr_status_t (*serf_ssl_need_client_cert_t)(</td><td> </td><td class="right">typedef apr_status_t (*serf_ssl_need_client_cert_t)(</td></tr>
      <tr><td class="left">    void *data,</td><td> </td><td class="right">    void *data,</td></tr>
      <tr><td class="left">    const char **cert_path);</td><td> </td><td class="right">    const char **cert_path);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef apr_status_t (*serf_ssl_need_cert_password_t)(</td><td> </td><td class="right">typedef apr_status_t (*serf_ssl_need_cert_password_t)(</td></tr>
      <tr><td class="left">    void *data,</td><td> </td><td class="right">    void *data,</td></tr>
      <tr><td class="left">    const char *cert_path,</td><td> </td><td class="right">    const char *cert_path,</td></tr>
      <tr><td class="left">    const char **password);</td><td> </td><td class="right">    const char **password);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Callback type for server certificate status info and OCSP responses.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Note that CERT can be NULL in case its called from the OCSP callback. */</span></td></tr>
      <tr><td class="left">typedef apr_status_t (*serf_ssl_need_server_cert_t)(</td><td> </td><td class="right">typedef apr_status_t (*serf_ssl_need_server_cert_t)(</td></tr>
      <tr><td class="left">    void *data,</td><td> </td><td class="right">    void *data,</td></tr>
      <tr><td class="left">    int failures,</td><td> </td><td class="right">    int failures,</td></tr>
      <tr><td class="left">    const serf_ssl_certificate_t *cert);</td><td> </td><td class="right">    const serf_ssl_certificate_t *cert);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef apr_status_t (*serf_ssl_server_cert_chain_cb_t)(</td><td> </td><td class="right">typedef apr_status_t (*serf_ssl_server_cert_chain_cb_t)(</td></tr>
      <tr><td class="left">    void *data,</td><td> </td><td class="right">    void *data,</td></tr>
      <tr><td class="left">    int failures,</td><td> </td><td class="right">    int failures,</td></tr>
      <tr><td class="left">    int error_depth,</td><td> </td><td class="right">    int error_depth,</td></tr>
      <tr><td class="left">    const serf_ssl_certificate_t * const * certs,</td><td> </td><td class="right">    const serf_ssl_certificate_t * const * certs,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 553<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 634<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_ssl_use_default_certificates(</td><td> </td><td class="right">apr_status_t serf_ssl_use_default_certificates(</td></tr>
      <tr><td class="left">    serf_ssl_context_t *context);</td><td> </td><td class="right">    serf_ssl_context_t *context);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Allow SNI indicators to be sent to the server.</td><td> </td><td class="right"> * Allow SNI indicators to be sent to the server.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_ssl_set_hostname(</td><td> </td><td class="right">apr_status_t serf_ssl_set_hostname(</td></tr>
      <tr><td class="left">    serf_ssl_context_t *context, const char *hostname);</td><td> </td><td class="right">    serf_ssl_context_t *context, const char *hostname);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_ssl_protocol_result_cb_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *data,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *protocol);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Enables ALPN negotiation with the server. Setups that the supported prot</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ocols</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * will be sent to the server, and enables handling the response via a call</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">back.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * SUPPORTED_PROTOCOLS is a comma separated list of protocols. No whitespac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * should be added as the values are used literally. E.g. "h2,http/1.1,h2-1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">6"</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns APR_ENOTIMPL when the ssl library doesn't implement ALPN.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * If successfull CALLBACK will be called as soon as the protocol is negoti</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * or directly after the secured stream is connected.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_ssl_negotiate_protocol(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_ssl_context_t *context,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *protocols,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_ssl_protocol_result_cb_t callback,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *callback_data);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the depth of the certificate.</td><td> </td><td class="right"> * Return the depth of the certificate.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int serf_ssl_cert_depth(</td><td> </td><td class="right">int serf_ssl_cert_depth(</td></tr>
      <tr><td class="left">    const serf_ssl_certificate_t *cert);</td><td> </td><td class="right">    const serf_ssl_certificate_t *cert);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Extract the fields of the issuer in a table with keys (E, CN, OU, O, L,</td><td> </td><td class="right"> * Extract the fields of the issuer in a table with keys (E, CN, OU, O, L,</td></tr>
      <tr><td class="left"> * ST and C). The returned table will be allocated in @a pool.</td><td> </td><td class="right"> * ST and C). The returned table will be allocated in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 611<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 716<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Adds the certificate @a cert to the list of trusted certificates in</td><td> </td><td class="right"> * Adds the certificate @a cert to the list of trusted certificates in</td></tr>
      <tr><td class="left"> * @a ssl_ctx that will be used for verification.</td><td> </td><td class="right"> * @a ssl_ctx that will be used for verification.</td></tr>
      <tr><td class="left"> * See also @a serf_ssl_load_cert_file.</td><td> </td><td class="right"> * See also @a serf_ssl_load_cert_file.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_ssl_trust_cert(</td><td> </td><td class="right">apr_status_t serf_ssl_trust_cert(</td></tr>
      <tr><td class="left">    serf_ssl_context_t *ssl_ctx,</td><td> </td><td class="right">    serf_ssl_context_t *ssl_ctx,</td></tr>
      <tr><td class="left">    serf_ssl_certificate_t *cert);</td><td> </td><td class="right">    serf_ssl_certificate_t *cert);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Load a CRL .pem file from @a file_path and enable CRL checking.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_ssl_add_crl_from_file(serf_ssl_context_t *ssl_ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        const char *file_path,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Enable or disable CRL checking of all server certificates.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @a enabled = 1 to enable CRL checking, 0 to disable CRL checking.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Default = disabled.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_ssl_check_crl(serf_ssl_context_t *ssl_ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                int enabled);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Enable or disable certificate status request (OCSP stapling) checking of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> all</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * server certificates.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @a enabled = 1 to enable checking, 0 to disable checking.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Default = disabled.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_ssl_check_cert_status_request(serf_ssl_context_t *ssl_ctx, int enabled</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Enable or disable SSL compression on a SSL session.</td><td> </td><td class="right"> * Enable or disable SSL compression on a SSL session.</td></tr>
      <tr><td class="left"> * @a enabled = 1 to enable compression, 0 to disable compression.</td><td> </td><td class="right"> * @a enabled = 1 to enable compression, 0 to disable compression.</td></tr>
      <tr><td class="left"> * Default = disabled.</td><td> </td><td class="right"> * Default = disabled.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_ssl_use_compression(</td><td> </td><td class="right">apr_status_t serf_ssl_use_compression(</td></tr>
      <tr><td class="left">    serf_ssl_context_t *ssl_ctx,</td><td> </td><td class="right">    serf_ssl_context_t *ssl_ctx,</td></tr>
      <tr><td class="left">    int enabled);</td><td> </td><td class="right">    int enabled);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_ssl_encrypt_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_ssl_encrypt_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 661<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 790<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">extern const serf_bucket_type_t serf_bucket_type_iovec;</td><td> </td><td class="right">extern const serf_bucket_type_t serf_bucket_type_iovec;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_IOVEC(b) SERF_BUCKET_CHECK((b), iovec)</td><td> </td><td class="right">#define SERF_BUCKET_IS_IOVEC(b) SERF_BUCKET_CHECK((b), iovec)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">serf_bucket_t *serf_bucket_iovec_create(</td><td> </td><td class="right">serf_bucket_t *serf_bucket_iovec_create(</td></tr>
      <tr><td class="left">    struct iovec vecs[],</td><td> </td><td class="right">    struct iovec vecs[],</td></tr>
      <tr><td class="left">    int len,</td><td> </td><td class="right">    int len,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_copy;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_BUCKET_IS_COPY(b) SERF_BUCKET_CHECK((b), copy)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf_bucket_copy_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *wrapped,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_size_t min_size,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ==================================================================== */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Reads a specific number of bytes from an inner bucket and forwards that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   to a callback, before reading the rest of the bucket normally.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   If the internal bucket is at EOF before the prefix length is read, the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   callback is called with whatever is read before returning EOF.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_prefix;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_BUCKET_IS_PREFIX(b) SERF_BUCKET_CHECK((b), prefix)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Callback for the prefix handler */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_bucket_prefix_handler_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *stream,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *data,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_size_t len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf_bucket_prefix_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *stream,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_size_t prefix_len,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_prefix_handler_t handler,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *handler_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ==================================================================== */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Creates two buckets, *HEAD and *TAIL, which together contain the output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   of STREAM. If there is enough data in STREAM, HEAD will be a bucket of a</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   least MIN_CHUNK_SIZE and will never be larget than MAX_CHUNK_SIZE.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   If STREAM is at EOF before MIN_CHUNK_SIZE, HEAD will contain the data,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   while TAIL is immediately at EOF.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   HEAD and TAIL will make sure that data read from TAIL will not break the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   data availability promises on HEAD. Passing an existing tail of this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   function as new stream may be handled specificaly, but the read promises</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   on all nodes ahead of stream will still hold.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   HEAD and TAIL are allocated in STREAM-&gt;allocator. STREAM will be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   destroyed when no longer referenced or after EOF.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void serf_bucket_split_create(serf_bucket_t **head,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                              serf_bucket_t **tail,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                              serf_bucket_t *stream,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                              apr_size_t min_chunk_size,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                              apr_size_t max_chunk_size);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Check if Serf bucket functions support Brotli (RFC 7932) format.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Return non-zero if Brotli is supported and zero otherwise.  If Brotli</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is not supported, the behavior of all related bucket functions such</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * as @a serf_bucket_brotli_decompress_create is undefined.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int serf_bucket_is_brotli_supported(void);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_brotli_decompress;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_BUCKET_IS_BROTLI_DECOMPRESS(b) \</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    SERF_BUCKET_CHECK((b), brotli_decompress)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @since New in 1.4. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_brotli_decompress_create(serf_bucket_t *stream,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                     serf_bucket_alloc_t *alloc);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* ### do we need a PIPE bucket type? they are simple apr_file_t objects */</td><td> </td><td class="right">/* ### do we need a PIPE bucket type? they are simple apr_file_t objects */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock">#endif /* !SERF_BUCKET_TYPES_H */</td><td> </td><td class="rblock">#endif /* !SERF_BUCKET_TYPES_H */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 17 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>25 lines changed or deleted</i></th><th><i> </i></th><th><i>242 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;serf_bucket_util.h (1.3.9)&nbsp;</th><th> </th><th>&nbsp;serf_bucket_util.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 63<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 63<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * then return it in the iovec.</td><td> </td><td class="right"> * then return it in the iovec.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_default_read_iovec(</td><td> </td><td class="right">apr_status_t serf_default_read_iovec(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    apr_size_t requested,</td><td> </td><td class="right">    apr_size_t requested,</td></tr>
      <tr><td class="left">    int vecs_size,</td><td> </td><td class="right">    int vecs_size,</td></tr>
      <tr><td class="left">    struct iovec *vecs,</td><td> </td><td class="right">    struct iovec *vecs,</td></tr>
      <tr><td class="left">    int *vecs_used);</td><td> </td><td class="right">    int *vecs_used);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Default implementation of the @see readline functionality.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function will use the @see read function, when possible optimized b</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the @a peek function to return the requested result.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_default_readline(serf_bucket_t *bucket, int acceptable,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                   int *found,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                   const char **data, apr_size_t *len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Default implementation of the @see read_for_sendfile functionality.</td><td> </td><td class="right"> * Default implementation of the @see read_for_sendfile functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will use the @see read function to get a block of memory,</td><td> </td><td class="right"> * This function will use the @see read function to get a block of memory,</td></tr>
      <tr><td class="left"> * then return it as a header. No file will be returned.</td><td> </td><td class="right"> * then return it as a header. No file will be returned.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_default_read_for_sendfile(</td><td> </td><td class="right">apr_status_t serf_default_read_for_sendfile(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    apr_size_t requested,</td><td> </td><td class="right">    apr_size_t requested,</td></tr>
      <tr><td class="left">    apr_hdtr_t *hdtr,</td><td> </td><td class="right">    apr_hdtr_t *hdtr,</td></tr>
      <tr><td class="left">    apr_file_t **file,</td><td> </td><td class="right">    apr_file_t **file,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 87<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 97<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * Default implementation of the @see read_bucket functionality.</td><td> </td><td class="right"> * Default implementation of the @see read_bucket functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will always return NULL, indicating that the @a type</td><td> </td><td class="right"> * This function will always return NULL, indicating that the @a type</td></tr>
      <tr><td class="left"> * of bucket cannot be found within @a bucket.</td><td> </td><td class="right"> * of bucket cannot be found within @a bucket.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">serf_bucket_t *serf_default_read_bucket(</td><td> </td><td class="right">serf_bucket_t *serf_default_read_bucket(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    const serf_bucket_type_t *type);</td><td> </td><td class="right">    const serf_bucket_type_t *type);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Default implementation of the @see peek functionality.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function will always state that there is no data available.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @since New in 1.4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_default_peek(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *bucket,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char **data,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_size_t *len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Default implementation of the @see destroy functionality.</td><td> </td><td class="right"> * Default implementation of the @see destroy functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will return the @a bucket to its allcoator.</td><td> </td><td class="right"> * This function will return the @a bucket to its allcoator.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void serf_default_destroy(</td><td> </td><td class="right">void serf_default_destroy(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket);</td><td> </td><td class="right">    serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Default implementation of the @see destroy functionality.</td><td> </td><td class="right"> * Default implementation of the @see destroy functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will return the @a bucket, and the data member to its</td><td> </td><td class="right"> * This function will return the @a bucket, and the data member to its</td></tr>
      <tr><td class="left"> * allocator.</td><td> </td><td class="right"> * allocator.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void serf_default_destroy_and_data(</td><td> </td><td class="right">void serf_default_destroy_and_data(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket);</td><td> </td><td class="right">    serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Implementation of a limited @see readline functionality.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function will use the @see read function, when possible optimized b</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the @a peek function to return the requested result.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_bucket_limited_readline(serf_bucket_t *bucket, int accept</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">able,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                          apr_size_t requested, int *found,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                          const char **data, apr_size_t *le</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Default implementation of the @see get_remaining functionality.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function will just return SERF_LENGTH_UNKNOWN.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_uint64_t serf_default_get_remaining(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *bucket);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Default implementation of the @see set_config functionality.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function will not do anything, it should be used in buckets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * that have no use for the shared config, and do not wrap other bucket(s).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_default_ignore_config(serf_bucket_t *bucket,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        serf_config_t *config);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Allocate @a size bytes of memory using @a allocator.</td><td> </td><td class="right"> * Allocate @a size bytes of memory using @a allocator.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Returns NULL of the requested memory size could not be allocated.</td><td> </td><td class="right"> * Returns NULL of the requested memory size could not be allocated.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *serf_bucket_mem_alloc(</td><td> </td><td class="right">void *serf_bucket_mem_alloc(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator,</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator,</td></tr>
      <tr><td class="left">    apr_size_t size);</td><td> </td><td class="right">    apr_size_t size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Allocate @a size bytes of memory using @a allocator and set all of the</td><td> </td><td class="right"> * Allocate @a size bytes of memory using @a allocator and set all of the</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 223<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 272<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    apr_size_t *len);</td><td> </td><td class="right">    apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * This structure is used as an intermediate data buffer for some "external
"</td><td> </td><td class="right"> * This structure is used as an intermediate data buffer for some "external
"</td></tr>
      <tr><td class="left"> * source of data. It works as a scratch pad area for incoming data to be</td><td> </td><td class="right"> * source of data. It works as a scratch pad area for incoming data to be</td></tr>
      <tr><td class="left"> * stored, and then returned as a ptr/len pair by the bucket read functions
.</td><td> </td><td class="right"> * stored, and then returned as a ptr/len pair by the bucket read functions
.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This structure should be initialized by calling @see serf_databuf_init.</td><td> </td><td class="right"> * This structure should be initialized by calling @see serf_databuf_init.</td></tr>
      <tr><td class="left"> * Users should not bother to zero the structure beforehand.</td><td> </td><td class="right"> * Users should not bother to zero the structure beforehand.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">typedef struct {</td><td> </td><td class="rblock">typedef struct <span class="insert">serf_databuf_t </span>{</td></tr>
      <tr><td class="left">    /** The current data position within the buffer. */</td><td> </td><td class="right">    /** The current data position within the buffer. */</td></tr>
      <tr><td class="left">    const char *current;</td><td> </td><td class="right">    const char *current;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /** Amount of data remaining in the buffer. */</td><td> </td><td class="right">    /** Amount of data remaining in the buffer. */</td></tr>
      <tr><td class="left">    apr_size_t remaining;</td><td> </td><td class="right">    apr_size_t remaining;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /** Callback function. */</td><td> </td><td class="right">    /** Callback function. */</td></tr>
      <tr><td class="left">    serf_databuf_reader_t read;</td><td> </td><td class="right">    serf_databuf_reader_t read;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /** A baton to hold context-specific data. */</td><td> </td><td class="right">    /** A baton to hold context-specific data. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 293<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 342<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">apr_status_t serf_databuf_peek(</td><td> </td><td class="right">apr_status_t serf_databuf_peek(</td></tr>
      <tr><td class="left">    serf_databuf_t *databuf,</td><td> </td><td class="right">    serf_databuf_t *databuf,</td></tr>
      <tr><td class="left">    const char **data,</td><td> </td><td class="right">    const char **data,</td></tr>
      <tr><td class="left">    apr_size_t *len);</td><td> </td><td class="right">    apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock">#endif /* !SERF_BUCKET_UTIL_H */</td><td> </td><td class="rblock">#endif /* !SERF_BUCKET_UTIL_H */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 5 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>54 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><div style='width:100%;' align='left' class='small'>This html diff was produced by rfcdiff 1.41.The latest version is available from <a href='http://tools.ietf.org/tools/rfcdiff/'>http://tools.ietf.org/tools/rfcdiff/</a></div>
</td></tr></table>
</body>
</html>
