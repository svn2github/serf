<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="serf, header, diff" />
    <meta name="description" content="Diff for header files between 0.3.1 and 0.4.0 versions of serf" />
    <link rel="stylesheet" type="text/css" href="../../../../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../../../../css/headers_diff.css" />
    
    
    <title>
        serf: headers diff between 0.3.1 and 0.4.0 versions
    </title>
    
    </head>

<body>
<table width='100%' cellpadding='0' cellspacing='0'><tr><td><table cellpadding='0' cellspacing='0'><tr><td align='center'><h1 class='tool'><a title='ABI tracker for serf' href='../../../../timeline/serf/index.html' class='tool'>ABI<br/>Tracker</a></h1></td><td width='30px;'></td><td><h1>(serf)</h1></td></tr></table><hr/>
<br/>
<br/>
<h1>Headers diff: <span class='version'>0.3.1</span> vs <span class='version'>0.4.0</span></h1><br/><br/> 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;serf.h (0.3.1)&nbsp;</th><th> </th><th>&nbsp;serf.h (0.4.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 47<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 47<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Forward declare some structures */</td><td> </td><td class="right">/* Forward declare some structures */</td></tr>
      <tr><td class="left">typedef struct serf_context_t serf_context_t;</td><td> </td><td class="right">typedef struct serf_context_t serf_context_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct serf_bucket_t serf_bucket_t;</td><td> </td><td class="right">typedef struct serf_bucket_t serf_bucket_t;</td></tr>
      <tr><td class="left">typedef struct serf_bucket_type_t serf_bucket_type_t;</td><td> </td><td class="right">typedef struct serf_bucket_type_t serf_bucket_type_t;</td></tr>
      <tr><td class="left">typedef struct serf_bucket_alloc_t serf_bucket_alloc_t;</td><td> </td><td class="right">typedef struct serf_bucket_alloc_t serf_bucket_alloc_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct serf_connection_t serf_connection_t;</td><td> </td><td class="right">typedef struct serf_connection_t serf_connection_t;</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_listener_t serf_listener_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_incoming_t serf_incoming_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct serf_incoming_request_t serf_incoming_request_t;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct serf_request_t serf_request_t;</td><td> </td><td class="right">typedef struct serf_request_t serf_request_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @defgroup serf high-level constructs</td><td> </td><td class="right"> * @defgroup serf high-level constructs</td></tr>
      <tr><td class="left"> * @ingroup serf</td><td> </td><td class="right"> * @ingroup serf</td></tr>
      <tr><td class="left"> * @{</td><td> </td><td class="right"> * @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 71<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 74<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/* This code is for when this is the last response on this connection:</td><td> </td><td class="right">/* This code is for when this is the last response on this connection:</td></tr>
      <tr><td class="left"> * i.e. do not send any more requests on this connection or expect</td><td> </td><td class="right"> * i.e. do not send any more requests on this connection or expect</td></tr>
      <tr><td class="left"> * any more responses.</td><td> </td><td class="right"> * any more responses.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_ERROR_CLOSING (APR_OS_START_USERERR + SERF_ERROR_RANGE + 1)</td><td> </td><td class="right">#define SERF_ERROR_CLOSING (APR_OS_START_USERERR + SERF_ERROR_RANGE + 1)</td></tr>
      <tr><td class="left">/* This code is for when the connection terminated before the request</td><td> </td><td class="right">/* This code is for when the connection terminated before the request</td></tr>
      <tr><td class="left"> * could be processed on the other side.</td><td> </td><td class="right"> * could be processed on the other side.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_ERROR_REQUEST_LOST (APR_OS_START_USERERR + SERF_ERROR_RANGE + 
2)</td><td> </td><td class="right">#define SERF_ERROR_REQUEST_LOST (APR_OS_START_USERERR + SERF_ERROR_RANGE + 
2)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* General authentication related errors */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_AUTHN_FAILED (APR_OS_START_USERERR + SERF_ERROR_RANGE + </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">90)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* None of the available authn mechanisms for the request are supported */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_AUTHN_NOT_SUPPORTED (APR_OS_START_USERERR + SERF_ERROR_R</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ANGE + 91)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Authn was requested by the server but the header lacked some attribute  </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_AUTHN_MISSING_ATTRIBUTE (APR_OS_START_USERERR + SERF_ERR</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">OR_RANGE + 92)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Authentication handler initialization related errors */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_ERROR_AUTHN_INITALIZATION_FAILED (APR_OS_START_USERERR +\</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    SERF_ERROR_RANGE + 93)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new context for serf operations.</td><td> </td><td class="right"> * Create a new context for serf operations.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * A serf context defines a control loop which processes multiple</td><td> </td><td class="right"> * A serf context defines a control loop which processes multiple</td></tr>
      <tr><td class="left"> * connections simultaneously.</td><td> </td><td class="right"> * connections simultaneously.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The context will be allocated within @a pool.</td><td> </td><td class="right"> * The context will be allocated within @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">SERF_DECLARE(serf_context_t *) serf_context_create(apr_pool_t *pool);</td><td> </td><td class="right">SERF_DECLARE(serf_context_t *) serf_context_create(apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 199<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 215<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * is based on the @see serf_request_deliver function, where the applicatio
n</td><td> </td><td class="right"> * is based on the @see serf_request_deliver function, where the applicatio
n</td></tr>
      <tr><td class="left"> * can assemble the appropriate bucket(s) before delivery.</td><td> </td><td class="right"> * can assemble the appropriate bucket(s) before delivery.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The returned bucket should live at least as long as the connection itsel
f.</td><td> </td><td class="right"> * The returned bucket should live at least as long as the connection itsel
f.</td></tr>
      <tr><td class="left"> * It is assumed that an appropriate allocator is passed in @a setup_baton.</td><td> </td><td class="right"> * It is assumed that an appropriate allocator is passed in @a setup_baton.</td></tr>
      <tr><td class="left"> * ### we may want to create a connection-level allocator and pass that</td><td> </td><td class="right"> * ### we may want to create a connection-level allocator and pass that</td></tr>
      <tr><td class="left"> * ### along. however, that allocator would *only* be used for this</td><td> </td><td class="right"> * ### along. however, that allocator would *only* be used for this</td></tr>
      <tr><td class="left"> * ### callback. it may be wasteful to create a per-conn allocator, so this</td><td> </td><td class="right"> * ### callback. it may be wasteful to create a per-conn allocator, so this</td></tr>
      <tr><td class="left"> * ### baton-based, app-responsible form might be best.</td><td> </td><td class="right"> * ### baton-based, app-responsible form might be best.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> * Responsibility for the bucket<span class="delete"> is passed to the serf library. It will </span>be</td><td> </td><td class="rblock"> * Responsibility for the bucket<span class="insert">s is passed to the serf library. They will 
</span>be</td></tr>
      <tr><td class="left"> * destroyed when the connection is closed.</td><td> </td><td class="right"> * destroyed when the connection is closed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All temporary allocations should be made in @a pool.</td><td> </td><td class="right"> * All temporary allocations should be made in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">typedef <span class="delete">serf_bucket_t *</span> (*serf_connection_setup_t)(apr_socket_t *skt,</td><td> </td><td class="rblock">typedef <span class="insert">apr_status_t</span> (*serf_connection_setup_t)(apr_socket_t *skt,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                   <span class="insert">serf_bucket_t **read_bkt</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                   serf_bucket_t **write_bk</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t,</span></td></tr>
      <tr><td class="left">                                                   void *setup_baton,</td><td> </td><td class="right">                                                   void *setup_baton,</td></tr>
      <tr><td class="left">                                                   apr_pool_t *pool);</td><td> </td><td class="right">                                                   apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * ### need to update docco w.r.t socket. became "stream" recently.</td><td> </td><td class="right"> * ### need to update docco w.r.t socket. became "stream" recently.</td></tr>
      <tr><td class="left"> * ### the stream does not have a barrier, this callback should generally</td><td> </td><td class="right"> * ### the stream does not have a barrier, this callback should generally</td></tr>
      <tr><td class="left"> * ### add a barrier around the stream before incorporating it into a</td><td> </td><td class="right"> * ### add a barrier around the stream before incorporating it into a</td></tr>
      <tr><td class="left"> * ### response bucket stack.</td><td> </td><td class="right"> * ### response bucket stack.</td></tr>
      <tr><td class="left"> * ### should serf add the barrier automatically to protect its data</td><td> </td><td class="right"> * ### should serf add the barrier automatically to protect its data</td></tr>
      <tr><td class="left"> * ### structure? i.e. the passed bucket becomes owned rather than</td><td> </td><td class="right"> * ### structure? i.e. the passed bucket becomes owned rather than</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 292<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 310<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * execution, or otherwise), then the connection will be reopened.</td><td> </td><td class="right"> * execution, or otherwise), then the connection will be reopened.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All temporary allocations should be made in @a pool.</td><td> </td><td class="right"> * All temporary allocations should be made in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef apr_status_t (*serf_response_handler_t)(serf_request_t *request,</td><td> </td><td class="right">typedef apr_status_t (*serf_response_handler_t)(serf_request_t *request,</td></tr>
      <tr><td class="left">                                                serf_bucket_t *response,</td><td> </td><td class="right">                                                serf_bucket_t *response,</td></tr>
      <tr><td class="left">                                                void *handler_baton,</td><td> </td><td class="right">                                                void *handler_baton,</td></tr>
      <tr><td class="left">                                                apr_pool_t *pool);</td><td> </td><td class="right">                                                apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Callback function to be implemented by the application, so that serf</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * can handle server and proxy authentication.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * code = 401 (server) or 407 (proxy).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * baton = the baton passed to serf_context_run.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * authn_type = one of "Basic", "Digest".</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_credentials_callback_t)(char **username,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    char **password,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_request_t *request, void *baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int code, const char *authn_type,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *realm,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Create a new connection associated with the @a ctx serf context.</td><td> </td><td class="right"> * Create a new connection associated with the @a ctx serf context.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * A connection will be created to (eventually) connect to the address</td><td> </td><td class="right"> * A connection will be created to (eventually) connect to the address</td></tr>
      <tr><td class="left"> * specified by @a address. The address must live at least as long as</td><td> </td><td class="right"> * specified by @a address. The address must live at least as long as</td></tr>
      <tr><td class="left"> * @a pool (thus, as long as the connection object).</td><td> </td><td class="right"> * @a pool (thus, as long as the connection object).</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The connection object will be allocated within @a pool. Clearing or</td><td> </td><td class="right"> * The connection object will be allocated within @a pool. Clearing or</td></tr>
      <tr><td class="left"> * destroying this pool will close the connection, and terminate any</td><td> </td><td class="right"> * destroying this pool will close the connection, and terminate any</td></tr>
      <tr><td class="left"> * outstanding requests or responses.</td><td> </td><td class="right"> * outstanding requests or responses.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 354<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 386<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">SERF_DECLARE(apr_status_t) serf_connection_create2(</td><td> </td><td class="right">SERF_DECLARE(apr_status_t) serf_connection_create2(</td></tr>
      <tr><td class="left">    serf_connection_t **conn,</td><td> </td><td class="right">    serf_connection_t **conn,</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_uri_t host_info,</td><td> </td><td class="right">    apr_uri_t host_info,</td></tr>
      <tr><td class="left">    serf_connection_setup_t setup,</td><td> </td><td class="right">    serf_connection_setup_t setup,</td></tr>
      <tr><td class="left">    void *setup_baton,</td><td> </td><td class="right">    void *setup_baton,</td></tr>
      <tr><td class="left">    serf_connection_closed_t closed,</td><td> </td><td class="right">    serf_connection_closed_t closed,</td></tr>
      <tr><td class="left">    void *closed_baton,</td><td> </td><td class="right">    void *closed_baton,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_accept_client_t)(serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        serf_listener_t *l,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        void *accept_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        apr_socket_t *insock,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(apr_status_t) serf_listener_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_listener_t **listener,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *host,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_uint16_t port,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *accept_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_accept_client_t accept_func,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_incoming_request_cb_t)(serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        serf_incoming_request_t *req,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        void *request_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                        apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(apr_status_t) serf_incoming_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_t **client,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_socket_t *insock,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *request_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_incoming_request_cb_t request,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t *pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Reset the connection, but re-open the socket again.</td><td> </td><td class="right"> * Reset the connection, but re-open the socket again.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">SERF_DECLARE(apr_status_t) serf_connection_reset(</td><td> </td><td class="right">SERF_DECLARE(apr_status_t) serf_connection_reset(</td></tr>
      <tr><td class="left">    serf_connection_t *conn);</td><td> </td><td class="right">    serf_connection_t *conn);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Close the connection associated with @a conn and cancel all pending requ
ests.</td><td> </td><td class="right"> * Close the connection associated with @a conn and cancel all pending requ
ests.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The closed callback passed to serf_connection_create() will be invoked</td><td> </td><td class="right"> * The closed callback passed to serf_connection_create() will be invoked</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 379<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 439<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Sets the maximum number of outstanding requests @a max_requests on the</td><td> </td><td class="right"> * Sets the maximum number of outstanding requests @a max_requests on the</td></tr>
      <tr><td class="left"> * connection @a conn. Setting max_requests to 0 means unlimited (the defau
lt).</td><td> </td><td class="right"> * connection @a conn. Setting max_requests to 0 means unlimited (the defau
lt).</td></tr>
      <tr><td class="left"> * Ex.: setting max_requests to 1 means a request is sent when a response o
n the</td><td> </td><td class="right"> * Ex.: setting max_requests to 1 means a request is sent when a response o
n the</td></tr>
      <tr><td class="left"> * previous request was received and handled.</td><td> </td><td class="right"> * previous request was received and handled.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">SERF_DECLARE(void)</td><td> </td><td class="right">SERF_DECLARE(void)</td></tr>
      <tr><td class="left">serf_connection_set_max_outstanding_requests(serf_connection_t *conn,</td><td> </td><td class="right">serf_connection_set_max_outstanding_requests(serf_connection_t *conn,</td></tr>
      <tr><td class="left">                                             unsigned int max_requests);</td><td> </td><td class="right">                                             unsigned int max_requests);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(void)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_connection_set_async_responses(serf_connection_t *conn,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    serf_response_acceptor_t acceptor,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    void *acceptor_baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    serf_response_handler_t handler,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                    void *handler_baton);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Setup the @a request for delivery on its connection.</td><td> </td><td class="right"> * Setup the @a request for delivery on its connection.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Right before this is invoked, @a pool will be built within the</td><td> </td><td class="right"> * Right before this is invoked, @a pool will be built within the</td></tr>
      <tr><td class="left"> * connection's pool for the request to use.  The associated response will</td><td> </td><td class="right"> * connection's pool for the request to use.  The associated response will</td></tr>
      <tr><td class="left"> * be allocated within that subpool. An associated bucket allocator will</td><td> </td><td class="right"> * be allocated within that subpool. An associated bucket allocator will</td></tr>
      <tr><td class="left"> * be built. These items may be fetched from the request object through</td><td> </td><td class="right"> * be built. These items may be fetched from the request object through</td></tr>
      <tr><td class="left"> * @see serf_request_get_pool or @see serf_request_get_alloc.</td><td> </td><td class="right"> * @see serf_request_get_pool or @see serf_request_get_alloc.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The content of the request is specified by the @a req_bkt bucket. When</td><td> </td><td class="right"> * The content of the request is specified by the @a req_bkt bucket. When</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 500<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 567<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * with the @a ctx serf context.</td><td> </td><td class="right"> * with the @a ctx serf context.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The next connection will be created to connect to the proxy server</td><td> </td><td class="right"> * The next connection will be created to connect to the proxy server</td></tr>
      <tr><td class="left"> * specified by @a address. The address must live at least as long as the</td><td> </td><td class="right"> * specified by @a address. The address must live at least as long as the</td></tr>
      <tr><td class="left"> * serf context.</td><td> </td><td class="right"> * serf context.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_config_proxy(</td><td> </td><td class="right">SERF_DECLARE(void) serf_config_proxy(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_sockaddr_t *address);</td><td> </td><td class="right">    apr_sockaddr_t *address);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Supported authentication types. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_AUTHN_NONE      0x00</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_AUTHN_BASIC     0x01</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_AUTHN_DIGEST    0x02</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_AUTHN_NTLM      0x04</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_AUTHN_NEGOTIATE 0x08</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_AUTHN_ALL       0xFF</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Define the authentication handlers that serf will try on incoming reques</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(void) serf_config_authn_types(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int authn_types);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Set the credentials callback handler.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(void) serf_config_credentials_callback(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t *ctx,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_credentials_callback_t cred_cb);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* ### maybe some connection control functions for flood? */</td><td> </td><td class="right">/* ### maybe some connection control functions for flood? */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*** Special bucket creation functions ***/</td><td> </td><td class="right">/*** Special bucket creation functions ***/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a bucket of type 'socket bucket'.</td><td> </td><td class="right"> * Create a bucket of type 'socket bucket'.</td></tr>
      <tr><td class="left"> * This is basically a wrapper around @a serf_bucket_socket_create, which</td><td> </td><td class="right"> * This is basically a wrapper around @a serf_bucket_socket_create, which</td></tr>
      <tr><td class="left"> * initializes the bucket using connection and/or context specific settings
.</td><td> </td><td class="right"> * initializes the bucket using connection and/or context specific settings
.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">SERF_DECLARE(serf_bucket_t *) serf_context_bucket_socket_create(</td><td> </td><td class="right">SERF_DECLARE(serf_bucket_t *) serf_context_bucket_socket_create(</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 902<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 991<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">SERF_DECLARE(apr_status_t) serf_debug__record_read(</td><td> </td><td class="right">SERF_DECLARE(apr_status_t) serf_debug__record_read(</td></tr>
      <tr><td class="left">    const serf_bucket_t *bucket,</td><td> </td><td class="right">    const serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    apr_status_t status);</td><td> </td><td class="right">    apr_status_t status);</td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_debug__entered_loop(serf_bucket_alloc_t *allocator)
;</td><td> </td><td class="right">SERF_DECLARE(void) serf_debug__entered_loop(serf_bucket_alloc_t *allocator)
;</td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_debug__closed_conn(serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">SERF_DECLARE(void) serf_debug__closed_conn(serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_debug__bucket_destroy(const serf_bucket_t *bucket);</td><td> </td><td class="right">SERF_DECLARE(void) serf_debug__bucket_destroy(const serf_bucket_t *bucket);</td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_debug__bucket_alloc_check(serf_bucket_alloc_t *allo
cator);</td><td> </td><td class="right">SERF_DECLARE(void) serf_debug__bucket_alloc_check(serf_bucket_alloc_t *allo
cator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Version info */</td><td> </td><td class="right">/* Version info */</td></tr>
      <tr><td class="left">#define SERF_MAJOR_VERSION 0</td><td> </td><td class="right">#define SERF_MAJOR_VERSION 0</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock">#define SERF_MINOR_VERSION <span class="delete">3</span></td><td> </td><td class="rblock">#define SERF_MINOR_VERSION <span class="insert">5</span></td></tr>
      <tr><td class="lblock">#define SERF_PATCH_VERSION <span class="delete">1</span></td><td> </td><td class="rblock">#define SERF_PATCH_VERSION <span class="insert">0</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Version number string */</td><td> </td><td class="right">/* Version number string */</td></tr>
      <tr><td class="left">#define SERF_VERSION_STRING APR_STRINGIFY(SERF_MAJOR_VERSION) "." \</td><td> </td><td class="right">#define SERF_VERSION_STRING APR_STRINGIFY(SERF_MAJOR_VERSION) "." \</td></tr>
      <tr><td class="left">                            APR_STRINGIFY(SERF_MINOR_VERSION) "." \</td><td> </td><td class="right">                            APR_STRINGIFY(SERF_MINOR_VERSION) "." \</td></tr>
      <tr><td class="left">                            APR_STRINGIFY(SERF_PATCH_VERSION)</td><td> </td><td class="right">                            APR_STRINGIFY(SERF_PATCH_VERSION)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check at compile time if the Serf version is at least a certain</td><td> </td><td class="right"> * Check at compile time if the Serf version is at least a certain</td></tr>
      <tr><td class="left"> * level.</td><td> </td><td class="right"> * level.</td></tr>
      <tr><td class="left"> * @param major The major version component of the version checked</td><td> </td><td class="right"> * @param major The major version component of the version checked</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 926<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 1015<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * for (e.g., the "3" of "1.3.0").</td><td> </td><td class="right"> * for (e.g., the "3" of "1.3.0").</td></tr>
      <tr><td class="left"> * @param patch The patch level component of the version checked</td><td> </td><td class="right"> * @param patch The patch level component of the version checked</td></tr>
      <tr><td class="left"> * for (e.g., the "0" of "1.3.0").</td><td> </td><td class="right"> * for (e.g., the "0" of "1.3.0").</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_VERSION_AT_LEAST(major,minor,patch)                         \</td><td> </td><td class="right">#define SERF_VERSION_AT_LEAST(major,minor,patch)                         \</td></tr>
      <tr><td class="left">(((major) &lt; SERF_MAJOR_VERSION)                                          \</td><td> </td><td class="right">(((major) &lt; SERF_MAJOR_VERSION)                                          \</td></tr>
      <tr><td class="left">  || ((major) == SERF_MAJOR_VERSION &amp;&amp; (minor) &lt; SERF_MINOR_VERSION)     \</td><td> </td><td class="right">  || ((major) == SERF_MAJOR_VERSION &amp;&amp; (minor) &lt; SERF_MINOR_VERSION)     \</td></tr>
      <tr><td class="left">   || ((major) == SERF_MAJOR_VERSION &amp;&amp; (minor) == SERF_MINOR_VERSION &amp;&amp; \</td><td> </td><td class="right">   || ((major) == SERF_MAJOR_VERSION &amp;&amp; (minor) == SERF_MINOR_VERSION &amp;&amp; \</td></tr>
      <tr><td class="left">            (patch) &lt;= SERF_PATCH_VERSION))</td><td> </td><td class="right">            (patch) &lt;= SERF_PATCH_VERSION))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns the version of the library the application has linked/loaded.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Values are returned in @a major, @a minor, and @a patch.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Applications will want to use this function to verify compatibility,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * expecially while serf has not reached a 1.0 milestone. APIs and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * semantics may change drastically until the library hits 1.0.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(void) serf_lib_version(int *major, int *minor, int *patch);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> * Every user of serf will want to deal with our various bucket types.</td><td> </td><td class="right"> * Every user of serf will want to deal with our various bucket types.</td></tr>
      <tr><td class="left"> * Go ahead and include that header right now.</td><td> </td><td class="right"> * Go ahead and include that header right now.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note: make sure this occurs outside of the C++ namespace block</td><td> </td><td class="right"> * Note: make sure this occurs outside of the C++ namespace block</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#include "serf_bucket_types.h"</td><td> </td><td class="right">#include "serf_bucket_types.h"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock">#endif /* !SERF_H */</td><td> </td><td class="rblock">#endif <span class="insert">   </span>/* !SERF_H */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 11 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>4 lines changed or deleted</i></th><th><i> </i></th><th><i>110 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;serf_bucket_types.h (0.3.1)&nbsp;</th><th> </th><th>&nbsp;serf_bucket_types.h (0.4.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 122<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 122<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    serf_bucket_t *response);</td><td> </td><td class="right">    serf_bucket_t *response);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Advise the response @a bucket that this was from a HEAD request and</td><td> </td><td class="right"> * Advise the response @a bucket that this was from a HEAD request and</td></tr>
      <tr><td class="left"> * that it should not expect to see a response body.</td><td> </td><td class="right"> * that it should not expect to see a response body.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_bucket_response_set_head(serf_bucket_t *bucket);</td><td> </td><td class="right">SERF_DECLARE(void) serf_bucket_response_set_head(serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_bwtp_fra</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">me;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_BUCKET_IS_BWTP_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_frame)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_bwtp_inc</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">oming_frame;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define SERF_BUCKET_IS_BWTP_INCOMING_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_i</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ncoming_frame)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(int) serf_bucket_bwtp_frame_get_channel(serf_bucket_t *hdr);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(int) serf_bucket_bwtp_frame_get_type(serf_bucket_t *hdr);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(const char *) serf_bucket_bwtp_frame_get_phrase(serf_bucket_t </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*hdr);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(serf_bucket_t *) serf_bucket_bwtp_frame_get_headers(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *hdr);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(serf_bucket_t *) serf_bucket_bwtp_channel_open(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int channel,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *URI,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(serf_bucket_t *) serf_bucket_bwtp_channel_close(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int channel,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(serf_bucket_t *) serf_bucket_bwtp_header_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int channel,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const char *phrase,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(serf_bucket_t *) serf_bucket_bwtp_message_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int channel,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *body,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(serf_bucket_t *) serf_bucket_bwtp_incoming_frame_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *bkt,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(apr_status_t) serf_bucket_bwtp_incoming_frame_wait_for_headers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *bkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* ==================================================================== */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_aggregat
e;</td><td> </td><td class="right">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_aggregat
e;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_AGGREGATE(b) SERF_BUCKET_CHECK((b), aggregate)</td><td> </td><td class="right">#define SERF_BUCKET_IS_AGGREGATE(b) SERF_BUCKET_CHECK((b), aggregate)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** serf_bucket_aggregate_cleanup will instantly destroy all buckets in</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    the aggregate bucket that have been read completely. Whereas normally,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    these buckets are destroyed on every read operation. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(void) serf_bucket_aggregate_cleanup(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *bucket, serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">SERF_DECLARE(serf_bucket_t *) serf_bucket_aggregate_create(</td><td> </td><td class="right">SERF_DECLARE(serf_bucket_t *) serf_bucket_aggregate_create(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Transform @a bucket in-place into an aggregate bucket. */</td><td> </td><td class="right">/** Transform @a bucket in-place into an aggregate bucket. */</td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_bucket_aggregate_become(serf_bucket_t *bucket);</td><td> </td><td class="right">SERF_DECLARE(void) serf_bucket_aggregate_become(serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_bucket_aggregate_prepend(</td><td> </td><td class="right">SERF_DECLARE(void) serf_bucket_aggregate_prepend(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    serf_bucket_t *prepend_bucket);</td><td> </td><td class="right">    serf_bucket_t *prepend_bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_bucket_aggregate_append(</td><td> </td><td class="right">SERF_DECLARE(void) serf_bucket_aggregate_append(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    serf_bucket_t *append_bucket);</td><td> </td><td class="right">    serf_bucket_t *append_bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_bucket_aggregate_eof_t)(void *baton, serf_bucke</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t_t *aggregate_bucket);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SERF_DECLARE(void) serf_bucket_aggregate_hold_open(serf_bucket_t *aggregate</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_bucket,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                   serf_bucket_aggregate_eo</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">f_t fn,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                   void *baton);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_bucket_aggregate_prepend_iovec(</td><td> </td><td class="right">SERF_DECLARE(void) serf_bucket_aggregate_prepend_iovec(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    struct iovec *vecs,</td><td> </td><td class="right">    struct iovec *vecs,</td></tr>
      <tr><td class="left">    int vecs_count);</td><td> </td><td class="right">    int vecs_count);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_bucket_aggregate_append_iovec(</td><td> </td><td class="right">SERF_DECLARE(void) serf_bucket_aggregate_append_iovec(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    struct iovec *vecs,</td><td> </td><td class="right">    struct iovec *vecs,</td></tr>
      <tr><td class="left">    int vecs_count);</td><td> </td><td class="right">    int vecs_count);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 302<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 357<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * @param baton opaque baton as passed to @see serf_bucket_headers_do</td><td> </td><td class="right"> * @param baton opaque baton as passed to @see serf_bucket_headers_do</td></tr>
      <tr><td class="left"> * @param key The header key from this iteration through the table</td><td> </td><td class="right"> * @param key The header key from this iteration through the table</td></tr>
      <tr><td class="left"> * @param value The header value from this iteration through the table</td><td> </td><td class="right"> * @param value The header value from this iteration through the table</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef int (serf_bucket_headers_do_callback_fn_t)(</td><td> </td><td class="right">typedef int (serf_bucket_headers_do_callback_fn_t)(</td></tr>
      <tr><td class="left">    void *baton,</td><td> </td><td class="right">    void *baton,</td></tr>
      <tr><td class="left">    const char *key,</td><td> </td><td class="right">    const char *key,</td></tr>
      <tr><td class="left">    const char *value);</td><td> </td><td class="right">    const char *value);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Iterates over all headers of the message and invokes the callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * function with header key and value. Stop iterating when no more</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * headers are available or when the callback function returned a</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * non-0 value.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="left"> * @param headers_bucket headers to iterate over</td><td> </td><td class="right"> * @param headers_bucket headers to iterate over</td></tr>
      <tr><td class="left"> * @param func callback routine to invoke for every header in the bucket</td><td> </td><td class="right"> * @param func callback routine to invoke for every header in the bucket</td></tr>
      <tr><td class="left"> * @param baton baton to pass on each invocation to func</td><td> </td><td class="right"> * @param baton baton to pass on each invocation to func</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">SERF_DECLARE(void) serf_bucket_headers_do(</td><td> </td><td class="right">SERF_DECLARE(void) serf_bucket_headers_do(</td></tr>
      <tr><td class="left">    serf_bucket_t *headers_bucket,</td><td> </td><td class="right">    serf_bucket_t *headers_bucket,</td></tr>
      <tr><td class="left">    serf_bucket_headers_do_callback_fn_t func,</td><td> </td><td class="right">    serf_bucket_headers_do_callback_fn_t func,</td></tr>
      <tr><td class="left">    void *baton);</td><td> </td><td class="right">    void *baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 4 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>68 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><div style='width:100%;' align='left' class='small'>This html diff was produced by rfcdiff 1.41.The latest version is available from <a href='http://tools.ietf.org/tools/rfcdiff/'>http://tools.ietf.org/tools/rfcdiff/</a></div>
</td></tr></table>
</body>
</html>
