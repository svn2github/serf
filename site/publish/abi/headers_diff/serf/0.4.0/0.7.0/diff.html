<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="serf, header, diff" />
    <meta name="description" content="Diff for header files between 0.4.0 and 0.7.0 versions of serf" />
    <link rel="stylesheet" type="text/css" href="../../../../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../../../../css/headers_diff.css" />
    
    
    <title>
        serf: headers diff between 0.4.0 and 0.7.0 versions
    </title>
    
    </head>

<body>
<table width='100%' cellpadding='0' cellspacing='0'><tr><td><table cellpadding='0' cellspacing='0'><tr><td align='center'><h1 class='tool'><a title='ABI tracker for serf' href='../../../../timeline/serf/index.html' class='tool'>ABI<br/>Tracker</a></h1></td><td width='30px;'></td><td><h1>(serf)</h1></td></tr></table><hr/>
<br/>
<br/>
<h1>Headers diff: <span class='version'>0.4.0</span> vs <span class='version'>0.7.0</span></h1><br/><br/> 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;serf.h (0.4.0)&nbsp;</th><th> </th><th>&nbsp;serf.h (0.7.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 33<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 33<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;apr.h&gt;</td><td> </td><td class="right">#include &lt;apr.h&gt;</td></tr>
      <tr><td class="left">#include &lt;apr_errno.h&gt;</td><td> </td><td class="right">#include &lt;apr_errno.h&gt;</td></tr>
      <tr><td class="left">#include &lt;apr_allocator.h&gt;</td><td> </td><td class="right">#include &lt;apr_allocator.h&gt;</td></tr>
      <tr><td class="left">#include &lt;apr_pools.h&gt;</td><td> </td><td class="right">#include &lt;apr_pools.h&gt;</td></tr>
      <tr><td class="left">#include &lt;apr_network_io.h&gt;</td><td> </td><td class="right">#include &lt;apr_network_io.h&gt;</td></tr>
      <tr><td class="left">#include &lt;apr_time.h&gt;</td><td> </td><td class="right">#include &lt;apr_time.h&gt;</td></tr>
      <tr><td class="left">#include &lt;apr_poll.h&gt;</td><td> </td><td class="right">#include &lt;apr_poll.h&gt;</td></tr>
      <tr><td class="left">#include &lt;apr_uri.h&gt;</td><td> </td><td class="right">#include &lt;apr_uri.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"><span class="delete">#include "serf_declare.h"</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Forward declare some structures */</td><td> </td><td class="right">/* Forward declare some structures */</td></tr>
      <tr><td class="left">typedef struct serf_context_t serf_context_t;</td><td> </td><td class="right">typedef struct serf_context_t serf_context_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct serf_bucket_t serf_bucket_t;</td><td> </td><td class="right">typedef struct serf_bucket_t serf_bucket_t;</td></tr>
      <tr><td class="left">typedef struct serf_bucket_type_t serf_bucket_type_t;</td><td> </td><td class="right">typedef struct serf_bucket_type_t serf_bucket_type_t;</td></tr>
      <tr><td class="left">typedef struct serf_bucket_alloc_t serf_bucket_alloc_t;</td><td> </td><td class="right">typedef struct serf_bucket_alloc_t serf_bucket_alloc_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 95<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 93<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    SERF_ERROR_RANGE + 93)</td><td> </td><td class="right">    SERF_ERROR_RANGE + 93)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new context for serf operations.</td><td> </td><td class="right"> * Create a new context for serf operations.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * A serf context defines a control loop which processes multiple</td><td> </td><td class="right"> * A serf context defines a control loop which processes multiple</td></tr>
      <tr><td class="left"> * connections simultaneously.</td><td> </td><td class="right"> * connections simultaneously.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The context will be allocated within @a pool.</td><td> </td><td class="right"> * The context will be allocated within @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_context_t *) serf_context_create(apr_pool_t</span> *pool);</td><td> </td><td class="rblock"><span class="insert">serf_context_t *serf_context_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    apr_pool_t</span> *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Callback function. Add a socket to the externally managed poll set.</td><td> </td><td class="right"> * Callback function. Add a socket to the externally managed poll set.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Both @a pfd and @a serf_baton should be used when calling serf_event_tri
gger</td><td> </td><td class="right"> * Both @a pfd and @a serf_baton should be used when calling serf_event_tri
gger</td></tr>
      <tr><td class="left"> * later.</td><td> </td><td class="right"> * later.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_socket_add_t)(void</span> *user_baton,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_socket_add_t)(</span></td></tr>
      <tr><td class="lblock">                                          apr_pollfd_t *pfd,</td><td> </td><td class="rblock"><span class="insert">    void</span> *user_baton,</td></tr>
      <tr><td class="lblock">                                          void *serf_baton);</td><td> </td><td class="rblock">    apr_pollfd_t *pfd,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    void *serf_baton);</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Callback function. Remove the socket, identified by both @a pfd and</td><td> </td><td class="right"> * Callback function. Remove the socket, identified by both @a pfd and</td></tr>
      <tr><td class="left"> * @a serf_baton from the externally managed poll set.</td><td> </td><td class="right"> * @a serf_baton from the externally managed poll set.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_socket_remove_t)(void</span> *user_baton,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_socket_remove_t)(</span></td></tr>
      <tr><td class="lblock">                                             apr_pollfd_t *pfd,</td><td> </td><td class="rblock"><span class="insert">    void</span> *user_baton,</td></tr>
      <tr><td class="lblock">                                             void *serf_baton);</td><td> </td><td class="rblock">    apr_pollfd_t *pfd,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    void *serf_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Create a new context for serf operations.</td><td> </td><td class="right">/* Create a new context for serf operations.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Use this function to make serf not use its internal control loop, but</td><td> </td><td class="right"> * Use this function to make serf not use its internal control loop, but</td></tr>
      <tr><td class="left"> * instead rely on an external event loop. Serf will use the @a addf and @a
 rmf</td><td> </td><td class="right"> * instead rely on an external event loop. Serf will use the @a addf and @a
 rmf</td></tr>
      <tr><td class="left"> * callbacks to notify of any event on a connection. The @a user_baton will
 be</td><td> </td><td class="right"> * callbacks to notify of any event on a connection. The @a user_baton will
 be</td></tr>
      <tr><td class="left"> * passed through the addf and rmf callbacks.</td><td> </td><td class="right"> * passed through the addf and rmf callbacks.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The context will be allocated within @a pool.</td><td> </td><td class="right"> * The context will be allocated within @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_context_t *) serf_context_create_ex(void</span> *user_baton,</td><td> </td><td class="rblock"><span class="insert">serf_context_t *serf_context_create_ex(</span></td></tr>
      <tr><td class="lblock">                                                      serf_socket_add_t <span class="delete">add</span></td><td> </td><td class="rblock"><span class="insert">    void</span> *user_baton,</td></tr>
      <tr><td class="lblock"><span class="delete">f,</span></td><td> </td><td class="rblock">    serf_socket_add_t <span class="insert">addf,</span></td></tr>
      <tr><td class="lblock">                                                      serf_socket_remove_t </td><td> </td><td class="rblock">    serf_socket_remove_t rmf,</td></tr>
      <tr><td class="lblock">rmf,</td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="lblock">                                                      apr_pool_t *pool);</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Make serf process events on a connection, identified by both @a pfd and</td><td> </td><td class="right"> * Make serf process events on a connection, identified by both @a pfd and</td></tr>
      <tr><td class="left"> * @a serf_baton.</td><td> </td><td class="right"> * @a serf_baton.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Any outbound data is delivered, and incoming data is made available to</td><td> </td><td class="right"> * Any outbound data is delivered, and incoming data is made available to</td></tr>
      <tr><td class="left"> * the associated response handlers and their buckets.</td><td> </td><td class="right"> * the associated response handlers and their buckets.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If any data is processed (incoming or outgoing), then this function will</td><td> </td><td class="right"> * If any data is processed (incoming or outgoing), then this function will</td></tr>
      <tr><td class="left"> * return with APR_SUCCESS.</td><td> </td><td class="right"> * return with APR_SUCCESS.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_event_trigger(serf_context_t</span> *s,</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_event_trigger(</span></td></tr>
      <tr><td class="lblock">                                              void *serf_baton,</td><td> </td><td class="rblock"><span class="insert">    serf_context_t</span> *s,</td></tr>
      <tr><td class="lblock">                                              const apr_pollfd_t *pfd);</td><td> </td><td class="rblock">    void *serf_baton,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    const apr_pollfd_t *pfd);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @see serf_context_run should not block at all. */</td><td> </td><td class="right">/** @see serf_context_run should not block at all. */</td></tr>
      <tr><td class="left">#define SERF_DURATION_NOBLOCK 0</td><td> </td><td class="right">#define SERF_DURATION_NOBLOCK 0</td></tr>
      <tr><td class="left">/** @see serf_context_run should run for (nearly) "forever". */</td><td> </td><td class="right">/** @see serf_context_run should run for (nearly) "forever". */</td></tr>
      <tr><td class="left">#define SERF_DURATION_FOREVER 2000000000        /* approx 1^31 */</td><td> </td><td class="right">#define SERF_DURATION_FOREVER 2000000000        /* approx 1^31 */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Run the main networking control loop.</td><td> </td><td class="right"> * Run the main networking control loop.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The set of connections defined by the serf context @a ctx are processed.</td><td> </td><td class="right"> * The set of connections defined by the serf context @a ctx are processed.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 164<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 168<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If any data is processed (incoming or outgoing), then this function will</td><td> </td><td class="right"> * If any data is processed (incoming or outgoing), then this function will</td></tr>
      <tr><td class="left"> * return with APR_SUCCESS. Typically, the caller will just want to call it</td><td> </td><td class="right"> * return with APR_SUCCESS. Typically, the caller will just want to call it</td></tr>
      <tr><td class="left"> * again to continue processing data.</td><td> </td><td class="right"> * again to continue processing data.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If no activity occurs within the specified timeout duration, then</td><td> </td><td class="right"> * If no activity occurs within the specified timeout duration, then</td></tr>
      <tr><td class="left"> * APR_TIMEUP is returned.</td><td> </td><td class="right"> * APR_TIMEUP is returned.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All temporary allocations will be made in @a pool.</td><td> </td><td class="right"> * All temporary allocations will be made in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_context_run(serf_context_t</span> *ctx,</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_context_run(</span></td></tr>
      <tr><td class="lblock">                                            apr_short_interval_time_t <span class="delete">durat</span></td><td> </td><td class="rblock"><span class="insert">    serf_context_t</span> *ctx,</td></tr>
      <tr><td class="lblock"><span class="delete">ion,</span></td><td> </td><td class="rblock">    apr_short_interval_time_t <span class="insert">duration,</span></td></tr>
      <tr><td class="lblock">                                            apr_pool_t *pool);</td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_context_prerun(serf_context_t</span> *ctx);</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_context_prerun(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_context_t</span> *ctx);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Callback function for progress information. @a progress indicates cumula
tive</td><td> </td><td class="right"> * Callback function for progress information. @a progress indicates cumula
tive</td></tr>
      <tr><td class="left"> * number of bytes read or written, for the whole context.</td><td> </td><td class="right"> * number of bytes read or written, for the whole context.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock">typedef void <span class="delete">(*serf_progress_t)(void</span> *progress_baton,</td><td> </td><td class="rblock">typedef void <span class="insert">(*serf_progress_t)(</span></td></tr>
      <tr><td class="lblock">                                apr_off_t read,</td><td> </td><td class="rblock"><span class="insert">    void</span> *progress_baton,</td></tr>
      <tr><td class="lblock">                                apr_off_t write);</td><td> </td><td class="rblock">    apr_off_t read,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_off_t write);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Sets the progress callback function. @a progress_func will be called eve
ry</td><td> </td><td class="right"> * Sets the progress callback function. @a progress_func will be called eve
ry</td></tr>
      <tr><td class="left"> * time bytes are read of or written on a socket.</td><td> </td><td class="right"> * time bytes are read of or written on a socket.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_context_set_progress_cb(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_context_set_progress_cb(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    const serf_progress_t progress_func,</td><td> </td><td class="right">    const serf_progress_t progress_func,</td></tr>
      <tr><td class="left">    void *progress_baton);</td><td> </td><td class="right">    void *progress_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @} */</td><td> </td><td class="right">/** @} */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @defgroup serf connections and requests</td><td> </td><td class="right"> * @defgroup serf connections and requests</td></tr>
      <tr><td class="left"> * @ingroup serf</td><td> </td><td class="right"> * @ingroup serf</td></tr>
      <tr><td class="left"> * @{</td><td> </td><td class="right"> * @{</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 220<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 227<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * ### we may want to create a connection-level allocator and pass that</td><td> </td><td class="right"> * ### we may want to create a connection-level allocator and pass that</td></tr>
      <tr><td class="left"> * ### along. however, that allocator would *only* be used for this</td><td> </td><td class="right"> * ### along. however, that allocator would *only* be used for this</td></tr>
      <tr><td class="left"> * ### callback. it may be wasteful to create a per-conn allocator, so this</td><td> </td><td class="right"> * ### callback. it may be wasteful to create a per-conn allocator, so this</td></tr>
      <tr><td class="left"> * ### baton-based, app-responsible form might be best.</td><td> </td><td class="right"> * ### baton-based, app-responsible form might be best.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Responsibility for the buckets is passed to the serf library. They will 
be</td><td> </td><td class="right"> * Responsibility for the buckets is passed to the serf library. They will 
be</td></tr>
      <tr><td class="left"> * destroyed when the connection is closed.</td><td> </td><td class="right"> * destroyed when the connection is closed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All temporary allocations should be made in @a pool.</td><td> </td><td class="right"> * All temporary allocations should be made in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_connection_setup_t)(apr_socket_t</span> *skt,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_connection_setup_t)(</span></td></tr>
      <tr><td class="lblock">                                                   serf_bucket_t <span class="delete">**read_bkt</span></td><td> </td><td class="rblock"><span class="insert">    apr_socket_t</span> *skt,</td></tr>
      <tr><td class="lblock"><span class="delete">,</span></td><td> </td><td class="rblock">    serf_bucket_t <span class="insert">**read_bkt,</span></td></tr>
      <tr><td class="lblock">                                                   serf_bucket_t <span class="delete">**write_bk</span></td><td> </td><td class="rblock">    serf_bucket_t <span class="insert">**write_bkt,</span></td></tr>
      <tr><td class="lblock"><span class="delete">t,</span></td><td> </td><td class="rblock">    void *setup_baton,</td></tr>
      <tr><td class="lblock">                                                   void *setup_baton,</td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="lblock">                                                   apr_pool_t *pool);</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * ### need to update docco w.r.t socket. became "stream" recently.</td><td> </td><td class="right"> * ### need to update docco w.r.t socket. became "stream" recently.</td></tr>
      <tr><td class="left"> * ### the stream does not have a barrier, this callback should generally</td><td> </td><td class="right"> * ### the stream does not have a barrier, this callback should generally</td></tr>
      <tr><td class="left"> * ### add a barrier around the stream before incorporating it into a</td><td> </td><td class="right"> * ### add a barrier around the stream before incorporating it into a</td></tr>
      <tr><td class="left"> * ### response bucket stack.</td><td> </td><td class="right"> * ### response bucket stack.</td></tr>
      <tr><td class="left"> * ### should serf add the barrier automatically to protect its data</td><td> </td><td class="right"> * ### should serf add the barrier automatically to protect its data</td></tr>
      <tr><td class="left"> * ### structure? i.e. the passed bucket becomes owned rather than</td><td> </td><td class="right"> * ### structure? i.e. the passed bucket becomes owned rather than</td></tr>
      <tr><td class="left"> * ### borrowed. that might suit overall semantics better.</td><td> </td><td class="right"> * ### borrowed. that might suit overall semantics better.</td></tr>
      <tr><td class="left"> * Accept an incoming response for @a request, and its @a socket. A bucket</td><td> </td><td class="right"> * Accept an incoming response for @a request, and its @a socket. A bucket</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 254<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 262<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * to bound the amount of memory stored in this pool -- to ensure that</td><td> </td><td class="right"> * to bound the amount of memory stored in this pool -- to ensure that</td></tr>
      <tr><td class="left"> * allocations are not proportional to the amount of data in the response.</td><td> </td><td class="right"> * allocations are not proportional to the amount of data in the response.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Responsibility for the bucket is passed to the serf library. It will be</td><td> </td><td class="right"> * Responsibility for the bucket is passed to the serf library. It will be</td></tr>
      <tr><td class="left"> * destroyed when the response has been fully read (the bucket returns an</td><td> </td><td class="right"> * destroyed when the response has been fully read (the bucket returns an</td></tr>
      <tr><td class="left"> * APR_EOF status from its read functions).</td><td> </td><td class="right"> * APR_EOF status from its read functions).</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All temporary allocations should be made in @a pool.</td><td> </td><td class="right"> * All temporary allocations should be made in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/* ### do we need to return an error? */</td><td> </td><td class="right">/* ### do we need to return an error? */</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock">typedef serf_bucket_t * <span class="delete">(*serf_response_acceptor_t)(serf_request_t *request</span></td><td> </td><td class="rblock">typedef serf_bucket_t * <span class="insert">(*serf_response_acceptor_t)(</span></td></tr>
      <tr><td class="lblock"><span class="delete">,</span></td><td> </td><td class="rblock"><span class="insert">    serf_request_t *request,</span></td></tr>
      <tr><td class="lblock">                                                    serf_bucket_t *stream,</td><td> </td><td class="rblock">    serf_bucket_t *stream,</td></tr>
      <tr><td class="lblock">                                                    void *acceptor_baton,</td><td> </td><td class="rblock">    void *acceptor_baton,</td></tr>
      <tr><td class="lblock">                                                    apr_pool_t *pool);</td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Notification callback for when a connection closes.</td><td> </td><td class="right"> * Notification callback for when a connection closes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This callback is used to inform an application that the @a conn</td><td> </td><td class="right"> * This callback is used to inform an application that the @a conn</td></tr>
      <tr><td class="left"> * connection has been (abnormally) closed. The @a closed_baton is the</td><td> </td><td class="right"> * connection has been (abnormally) closed. The @a closed_baton is the</td></tr>
      <tr><td class="left"> * baton provided when the connection was first opened. The reason for</td><td> </td><td class="right"> * baton provided when the connection was first opened. The reason for</td></tr>
      <tr><td class="left"> * closure is given in @a why, and will be APR_SUCCESS if the application</td><td> </td><td class="right"> * closure is given in @a why, and will be APR_SUCCESS if the application</td></tr>
      <tr><td class="left"> * requested closure (by clearing the pool used to allocate this</td><td> </td><td class="right"> * requested closure (by clearing the pool used to allocate this</td></tr>
      <tr><td class="left"> * connection or calling serf_connection_close).</td><td> </td><td class="right"> * connection or calling serf_connection_close).</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All temporary allocations should be made in @a pool.</td><td> </td><td class="right"> * All temporary allocations should be made in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock">typedef void <span class="delete">(*serf_connection_closed_t)(serf_connection_t</span> *conn,</td><td> </td><td class="rblock">typedef void <span class="insert">(*serf_connection_closed_t)(</span></td></tr>
      <tr><td class="lblock">                                         void *closed_baton,</td><td> </td><td class="rblock"><span class="insert">    serf_connection_t</span> *conn,</td></tr>
      <tr><td class="lblock">                                         apr_status_t why,</td><td> </td><td class="rblock">    void *closed_baton,</td></tr>
      <tr><td class="lblock">                                         apr_pool_t *pool);</td><td> </td><td class="rblock">    apr_status_t why,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Response data has arrived and should be processed.</td><td> </td><td class="right"> * Response data has arrived and should be processed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Whenever response data for @a request arrives (initially, or continued d
ata</td><td> </td><td class="right"> * Whenever response data for @a request arrives (initially, or continued d
ata</td></tr>
      <tr><td class="left"> * arrival), this handler is invoked. The response data is available in the</td><td> </td><td class="right"> * arrival), this handler is invoked. The response data is available in the</td></tr>
      <tr><td class="left"> * @a response bucket. The @a handler_baton is passed along from the baton</td><td> </td><td class="right"> * @a response bucket. The @a handler_baton is passed along from the baton</td></tr>
      <tr><td class="left"> * provided by the request setup callback (@see serf_request_setup_t).</td><td> </td><td class="right"> * provided by the request setup callback (@see serf_request_setup_t).</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The handler MUST process data from the @a response bucket until the</td><td> </td><td class="right"> * The handler MUST process data from the @a response bucket until the</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 304<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 314<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * Note: if the connection closed (at the request of the application, or</td><td> </td><td class="right"> * Note: if the connection closed (at the request of the application, or</td></tr>
      <tr><td class="left"> * because of an (abnormal) termination) while a request is being delivered
,</td><td> </td><td class="right"> * because of an (abnormal) termination) while a request is being delivered
,</td></tr>
      <tr><td class="left"> * or before a response arrives, then @a response will be NULL. This is the</td><td> </td><td class="right"> * or before a response arrives, then @a response will be NULL. This is the</td></tr>
      <tr><td class="left"> * signal that the request was not delivered properly, and no further</td><td> </td><td class="right"> * signal that the request was not delivered properly, and no further</td></tr>
      <tr><td class="left"> * response should be expected (this callback will not be invoked again).</td><td> </td><td class="right"> * response should be expected (this callback will not be invoked again).</td></tr>
      <tr><td class="left"> * If a request is injected into the connection (during this callback's</td><td> </td><td class="right"> * If a request is injected into the connection (during this callback's</td></tr>
      <tr><td class="left"> * execution, or otherwise), then the connection will be reopened.</td><td> </td><td class="right"> * execution, or otherwise), then the connection will be reopened.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All temporary allocations should be made in @a pool.</td><td> </td><td class="right"> * All temporary allocations should be made in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_response_handler_t)(serf_request_t</span> *request,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_response_handler_t)(</span></td></tr>
      <tr><td class="lblock">                                                serf_bucket_t *response,</td><td> </td><td class="rblock"><span class="insert">    serf_request_t</span> *request,</td></tr>
      <tr><td class="lblock">                                                void *handler_baton,</td><td> </td><td class="rblock">    serf_bucket_t *response,</td></tr>
      <tr><td class="lblock">                                                apr_pool_t *pool);</td><td> </td><td class="rblock">    void *handler_baton,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Callback function to be implemented by the application, so that serf</td><td> </td><td class="right"> * Callback function to be implemented by the application, so that serf</td></tr>
      <tr><td class="left"> * can handle server and proxy authentication.</td><td> </td><td class="right"> * can handle server and proxy authentication.</td></tr>
      <tr><td class="left"> * code = 401 (server) or 407 (proxy).</td><td> </td><td class="right"> * code = 401 (server) or 407 (proxy).</td></tr>
      <tr><td class="left"> * baton = the baton passed to serf_context_run.</td><td> </td><td class="right"> * baton = the baton passed to serf_context_run.</td></tr>
      <tr><td class="left"> * authn_type = one of "Basic", "Digest".</td><td> </td><td class="right"> * authn_type = one of "Basic", "Digest".</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_credentials_callback_t)(char</span> **username,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_credentials_callback_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    char</span> **username,</td></tr>
      <tr><td class="left">    char **password,</td><td> </td><td class="right">    char **password,</td></tr>
      <tr><td class="left">    serf_request_t *request, void *baton,</td><td> </td><td class="right">    serf_request_t *request, void *baton,</td></tr>
      <tr><td class="left">    int code, const char *authn_type,</td><td> </td><td class="right">    int code, const char *authn_type,</td></tr>
      <tr><td class="left">    const char *realm,</td><td> </td><td class="right">    const char *realm,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new connection associated with the @a ctx serf context.</td><td> </td><td class="right"> * Create a new connection associated with the @a ctx serf context.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * A connection will be created to (eventually) connect to the address</td><td> </td><td class="right"> * A connection will be created to (eventually) connect to the address</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 344<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 356<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * When the connection is closed (upon request or because of an error),</td><td> </td><td class="right"> * When the connection is closed (upon request or because of an error),</td></tr>
      <tr><td class="left"> * then the @a closed callback is invoked, and @a closed_baton is passed.</td><td> </td><td class="right"> * then the @a closed callback is invoked, and @a closed_baton is passed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ### doc on setup(_baton). tweak below comment re: acceptor.</td><td> </td><td class="right"> * ### doc on setup(_baton). tweak below comment re: acceptor.</td></tr>
      <tr><td class="left"> * NULL may be passed for @a acceptor and @a closed; default implementation
s</td><td> </td><td class="right"> * NULL may be passed for @a acceptor and @a closed; default implementation
s</td></tr>
      <tr><td class="left"> * will be used.</td><td> </td><td class="right"> * will be used.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note: the connection is not made immediately. It will be opened on</td><td> </td><td class="right"> * Note: the connection is not made immediately. It will be opened on</td></tr>
      <tr><td class="left"> * the next call to @see serf_context_run.</td><td> </td><td class="right"> * the next call to @see serf_context_run.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_connection_t *) </span>serf_connection_create(</td><td> </td><td class="rblock"><span class="insert">serf_connection_t *</span>serf_connection_create(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_sockaddr_t *address,</td><td> </td><td class="right">    apr_sockaddr_t *address,</td></tr>
      <tr><td class="left">    serf_connection_setup_t setup,</td><td> </td><td class="right">    serf_connection_setup_t setup,</td></tr>
      <tr><td class="left">    void *setup_baton,</td><td> </td><td class="right">    void *setup_baton,</td></tr>
      <tr><td class="left">    serf_connection_closed_t closed,</td><td> </td><td class="right">    serf_connection_closed_t closed,</td></tr>
      <tr><td class="left">    void *closed_baton,</td><td> </td><td class="right">    void *closed_baton,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new connection associated with the @a ctx serf context.</td><td> </td><td class="right"> * Create a new connection associated with the @a ctx serf context.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 376<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 388<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * When the connection is closed (upon request or because of an error),</td><td> </td><td class="right"> * When the connection is closed (upon request or because of an error),</td></tr>
      <tr><td class="left"> * then the @a closed callback is invoked, and @a closed_baton is passed.</td><td> </td><td class="right"> * then the @a closed callback is invoked, and @a closed_baton is passed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ### doc on setup(_baton). tweak below comment re: acceptor.</td><td> </td><td class="right"> * ### doc on setup(_baton). tweak below comment re: acceptor.</td></tr>
      <tr><td class="left"> * NULL may be passed for @a acceptor and @a closed; default implementation
s</td><td> </td><td class="right"> * NULL may be passed for @a acceptor and @a closed; default implementation
s</td></tr>
      <tr><td class="left"> * will be used.</td><td> </td><td class="right"> * will be used.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note: the connection is not made immediately. It will be opened on</td><td> </td><td class="right"> * Note: the connection is not made immediately. It will be opened on</td></tr>
      <tr><td class="left"> * the next call to @see serf_context_run.</td><td> </td><td class="right"> * the next call to @see serf_context_run.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_connection_create2(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_connection_create2(</td></tr>
      <tr><td class="left">    serf_connection_t **conn,</td><td> </td><td class="right">    serf_connection_t **conn,</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_uri_t host_info,</td><td> </td><td class="right">    apr_uri_t host_info,</td></tr>
      <tr><td class="left">    serf_connection_setup_t setup,</td><td> </td><td class="right">    serf_connection_setup_t setup,</td></tr>
      <tr><td class="left">    void *setup_baton,</td><td> </td><td class="right">    void *setup_baton,</td></tr>
      <tr><td class="left">    serf_connection_closed_t closed,</td><td> </td><td class="right">    serf_connection_closed_t closed,</td></tr>
      <tr><td class="left">    void *closed_baton,</td><td> </td><td class="right">    void *closed_baton,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_accept_client_t)(serf_context_t</span> *ctx,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_accept_client_t)(</span></td></tr>
      <tr><td class="lblock">                                        serf_listener_t *l,</td><td> </td><td class="rblock"><span class="insert">    serf_context_t</span> *ctx,</td></tr>
      <tr><td class="lblock">                                        void *accept_baton,</td><td> </td><td class="rblock">    serf_listener_t *l,</td></tr>
      <tr><td class="lblock">                                        apr_socket_t *insock,</td><td> </td><td class="rblock">    void *accept_baton,</td></tr>
      <tr><td class="lblock">                                        apr_pool_t *pool);</td><td> </td><td class="rblock">    apr_socket_t *insock,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_listener_create(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_listener_create(</td></tr>
      <tr><td class="left">    serf_listener_t **listener,</td><td> </td><td class="right">    serf_listener_t **listener,</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    const char *host,</td><td> </td><td class="right">    const char *host,</td></tr>
      <tr><td class="left">    apr_uint16_t port,</td><td> </td><td class="right">    apr_uint16_t port,</td></tr>
      <tr><td class="left">    void *accept_baton,</td><td> </td><td class="right">    void *accept_baton,</td></tr>
      <tr><td class="left">    serf_accept_client_t accept_func,</td><td> </td><td class="right">    serf_accept_client_t accept_func,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_incoming_request_cb_t)(serf_context_t</span> *ctx,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_incoming_request_cb_t)(</span></td></tr>
      <tr><td class="lblock">                                        serf_incoming_request_t *req,</td><td> </td><td class="rblock"><span class="insert">    serf_context_t</span> *ctx,</td></tr>
      <tr><td class="lblock">                                        void *request_baton,</td><td> </td><td class="rblock">    serf_incoming_request_t *req,</td></tr>
      <tr><td class="lblock">                                        apr_pool_t *pool);</td><td> </td><td class="rblock">    void *request_baton,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_incoming_create(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_incoming_create(</td></tr>
      <tr><td class="left">    serf_incoming_t **client,</td><td> </td><td class="right">    serf_incoming_t **client,</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_socket_t *insock,</td><td> </td><td class="right">    apr_socket_t *insock,</td></tr>
      <tr><td class="left">    void *request_baton,</td><td> </td><td class="right">    void *request_baton,</td></tr>
      <tr><td class="left">    serf_incoming_request_cb_t request,</td><td> </td><td class="right">    serf_incoming_request_cb_t request,</td></tr>
      <tr><td class="left">    apr_pool_t *pool);</td><td> </td><td class="right">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Reset the connection, but re-open the socket again.</td><td> </td><td class="right"> * Reset the connection, but re-open the socket again.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_connection_reset(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_connection_reset(</td></tr>
      <tr><td class="left">    serf_connection_t *conn);</td><td> </td><td class="right">    serf_connection_t *conn);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Close the connection associated with @a conn and cancel all pending requ
ests.</td><td> </td><td class="right"> * Close the connection associated with @a conn and cancel all pending requ
ests.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The closed callback passed to serf_connection_create() will be invoked</td><td> </td><td class="right"> * The closed callback passed to serf_connection_create() will be invoked</td></tr>
      <tr><td class="left"> * with APR_SUCCESS.</td><td> </td><td class="right"> * with APR_SUCCESS.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_connection_close(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_connection_close(</td></tr>
      <tr><td class="left">    serf_connection_t *conn);</td><td> </td><td class="right">    serf_connection_t *conn);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Sets the maximum number of outstanding requests @a max_requests on the</td><td> </td><td class="right"> * Sets the maximum number of outstanding requests @a max_requests on the</td></tr>
      <tr><td class="left"> * connection @a conn. Setting max_requests to 0 means unlimited (the defau
lt).</td><td> </td><td class="right"> * connection @a conn. Setting max_requests to 0 means unlimited (the defau
lt).</td></tr>
      <tr><td class="left"> * Ex.: setting max_requests to 1 means a request is sent when a response o
n the</td><td> </td><td class="right"> * Ex.: setting max_requests to 1 means a request is sent when a response o
n the</td></tr>
      <tr><td class="left"> * previous request was received and handled.</td><td> </td><td class="right"> * previous request was received and handled.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span></td><td> </td><td class="rblock"><span class="insert">void serf_connection_set_max_outstanding_requests(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_connection_set_max_outstanding_requests(serf_connection_t</span> *conn,</td><td> </td><td class="rblock"><span class="insert">    serf_connection_t</span> *conn,</td></tr>
      <tr><td class="lblock">                                             unsigned int max_requests);</td><td> </td><td class="rblock">    unsigned int max_requests);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0025"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span></td><td> </td><td class="rblock"><span class="insert">void serf_connection_set_async_responses(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_connection_set_async_responses(serf_connection_t</span> *conn,</td><td> </td><td class="rblock"><span class="insert">    serf_connection_t</span> *conn,</td></tr>
      <tr><td class="lblock">                                    serf_response_acceptor_t acceptor,</td><td> </td><td class="rblock">    serf_response_acceptor_t acceptor,</td></tr>
      <tr><td class="lblock">                                    void *acceptor_baton,</td><td> </td><td class="rblock">    void *acceptor_baton,</td></tr>
      <tr><td class="lblock">                                    serf_response_handler_t handler,</td><td> </td><td class="rblock">    serf_response_handler_t handler,</td></tr>
      <tr><td class="lblock">                                    void *handler_baton);</td><td> </td><td class="rblock">    void *handler_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Setup the @a request for delivery on its connection.</td><td> </td><td class="right"> * Setup the @a request for delivery on its connection.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Right before this is invoked, @a pool will be built within the</td><td> </td><td class="right"> * Right before this is invoked, @a pool will be built within the</td></tr>
      <tr><td class="left"> * connection's pool for the request to use.  The associated response will</td><td> </td><td class="right"> * connection's pool for the request to use.  The associated response will</td></tr>
      <tr><td class="left"> * be allocated within that subpool. An associated bucket allocator will</td><td> </td><td class="right"> * be allocated within that subpool. An associated bucket allocator will</td></tr>
      <tr><td class="left"> * be built. These items may be fetched from the request object through</td><td> </td><td class="right"> * be built. These items may be fetched from the request object through</td></tr>
      <tr><td class="left"> * @see serf_request_get_pool or @see serf_request_get_alloc.</td><td> </td><td class="right"> * @see serf_request_get_pool or @see serf_request_get_alloc.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The content of the request is specified by the @a req_bkt bucket. When</td><td> </td><td class="right"> * The content of the request is specified by the @a req_bkt bucket. When</td></tr>
      <tr><td class="left"> * a response arrives, the @a acceptor callback will be invoked (along with</td><td> </td><td class="right"> * a response arrives, the @a acceptor callback will be invoked (along with</td></tr>
      <tr><td class="left"> * the @a acceptor_baton) to produce a response bucket. That bucket will th
en</td><td> </td><td class="right"> * the @a acceptor_baton) to produce a response bucket. That bucket will th
en</td></tr>
      <tr><td class="left"> * be passed to @a handler, along with the @a handler_baton.</td><td> </td><td class="right"> * be passed to @a handler, along with the @a handler_baton.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The responsibility for the request bucket is passed to the request</td><td> </td><td class="right"> * The responsibility for the request bucket is passed to the request</td></tr>
      <tr><td class="left"> * object. When the request is done with the bucket, it will be destroyed.</td><td> </td><td class="right"> * object. When the request is done with the bucket, it will be destroyed.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0026"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_request_setup_t)(serf_request_t</span> *request,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_request_setup_t)(</span></td></tr>
      <tr><td class="lblock">                                             void *setup_baton,</td><td> </td><td class="rblock"><span class="insert">    serf_request_t</span> *request,</td></tr>
      <tr><td class="lblock">                                             serf_bucket_t **req_bkt,</td><td> </td><td class="rblock">    void *setup_baton,</td></tr>
      <tr><td class="lblock">                                             serf_response_acceptor_t <span class="delete">*acce</span></td><td> </td><td class="rblock">    serf_bucket_t **req_bkt,</td></tr>
      <tr><td class="lblock"><span class="delete">ptor,</span></td><td> </td><td class="rblock">    serf_response_acceptor_t <span class="insert">*acceptor,</span></td></tr>
      <tr><td class="lblock">                                             void **acceptor_baton,</td><td> </td><td class="rblock">    void **acceptor_baton,</td></tr>
      <tr><td class="lblock">                                             serf_response_handler_t <span class="delete">*handl</span></td><td> </td><td class="rblock">    serf_response_handler_t <span class="insert">*handler,</span></td></tr>
      <tr><td class="lblock"><span class="delete">er,</span></td><td> </td><td class="rblock">    void **handler_baton,</td></tr>
      <tr><td class="lblock">                                             void **handler_baton,</td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="lblock">                                             apr_pool_t *pool);</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Construct a request object for the @a conn connection.</td><td> </td><td class="right"> * Construct a request object for the @a conn connection.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * When it is time to deliver the request, the @a setup callback will</td><td> </td><td class="right"> * When it is time to deliver the request, the @a setup callback will</td></tr>
      <tr><td class="left"> * be invoked with the @a setup_baton passed into it to complete the</td><td> </td><td class="right"> * be invoked with the @a setup_baton passed into it to complete the</td></tr>
      <tr><td class="left"> * construction of the request object.</td><td> </td><td class="right"> * construction of the request object.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If the request has not (yet) been delivered, then it may be canceled</td><td> </td><td class="right"> * If the request has not (yet) been delivered, then it may be canceled</td></tr>
      <tr><td class="left"> * with @see serf_request_cancel.</td><td> </td><td class="right"> * with @see serf_request_cancel.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Invoking any calls other than @see serf_request_cancel before the setup</td><td> </td><td class="right"> * Invoking any calls other than @see serf_request_cancel before the setup</td></tr>
      <tr><td class="left"> * callback executes is not supported.</td><td> </td><td class="right"> * callback executes is not supported.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0027"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_request_t *) </span>serf_connection_request_create(</td><td> </td><td class="rblock"><span class="insert">serf_request_t *</span>serf_connection_request_create(</td></tr>
      <tr><td class="left">    serf_connection_t *conn,</td><td> </td><td class="right">    serf_connection_t *conn,</td></tr>
      <tr><td class="left">    serf_request_setup_t setup,</td><td> </td><td class="right">    serf_request_setup_t setup,</td></tr>
      <tr><td class="left">    void *setup_baton);</td><td> </td><td class="right">    void *setup_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Construct a request object for the @a conn connection, add it in the</td><td> </td><td class="right"> * Construct a request object for the @a conn connection, add it in the</td></tr>
      <tr><td class="left"> * list as the next to-be-written request before all unwritten requests.</td><td> </td><td class="right"> * list as the next to-be-written request before all unwritten requests.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * When it is time to deliver the request, the @a setup callback will</td><td> </td><td class="right"> * When it is time to deliver the request, the @a setup callback will</td></tr>
      <tr><td class="left"> * be invoked with the @a setup_baton passed into it to complete the</td><td> </td><td class="right"> * be invoked with the @a setup_baton passed into it to complete the</td></tr>
      <tr><td class="left"> * construction of the request object.</td><td> </td><td class="right"> * construction of the request object.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If the request has not (yet) been delivered, then it may be canceled</td><td> </td><td class="right"> * If the request has not (yet) been delivered, then it may be canceled</td></tr>
      <tr><td class="left"> * with @see serf_request_cancel.</td><td> </td><td class="right"> * with @see serf_request_cancel.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Invoking any calls other than @see serf_request_cancel before the setup</td><td> </td><td class="right"> * Invoking any calls other than @see serf_request_cancel before the setup</td></tr>
      <tr><td class="left"> * callback executes is not supported.</td><td> </td><td class="right"> * callback executes is not supported.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0028"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_request_t *) </span>serf_connection_priority_request_create(</td><td> </td><td class="rblock"><span class="insert">serf_request_t *</span>serf_connection_priority_request_create(</td></tr>
      <tr><td class="left">    serf_connection_t *conn,</td><td> </td><td class="right">    serf_connection_t *conn,</td></tr>
      <tr><td class="left">    serf_request_setup_t setup,</td><td> </td><td class="right">    serf_request_setup_t setup,</td></tr>
      <tr><td class="left">    void *setup_baton);</td><td> </td><td class="right">    void *setup_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Cancel the request specified by the @a request object.</td><td> </td><td class="right"> * Cancel the request specified by the @a request object.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If the request has been scheduled for delivery, then its response</td><td> </td><td class="right"> * If the request has been scheduled for delivery, then its response</td></tr>
      <tr><td class="left"> * handler will be run, passing NULL for the response bucket.</td><td> </td><td class="right"> * handler will be run, passing NULL for the response bucket.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If the request has already been (partially or fully) delivered, then</td><td> </td><td class="right"> * If the request has already been (partially or fully) delivered, then</td></tr>
      <tr><td class="left"> * APR_EBUSY is returned and the request is *NOT* canceled. To properly</td><td> </td><td class="right"> * APR_EBUSY is returned and the request is *NOT* canceled. To properly</td></tr>
      <tr><td class="left"> * cancel the request, the connection must be closed (by clearing or</td><td> </td><td class="right"> * cancel the request, the connection must be closed (by clearing or</td></tr>
      <tr><td class="left"> * destroying its associated pool).</td><td> </td><td class="right"> * destroying its associated pool).</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0029"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_request_cancel(serf_request_t</span> *request);</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_request_cancel(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_request_t</span> *request);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the pool associated with @a request.</td><td> </td><td class="right"> * Return the pool associated with @a request.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * WARNING: be very careful about the kinds of things placed into this</td><td> </td><td class="right"> * WARNING: be very careful about the kinds of things placed into this</td></tr>
      <tr><td class="left"> * pool. In particular, all allocation should be bounded in size, rather</td><td> </td><td class="right"> * pool. In particular, all allocation should be bounded in size, rather</td></tr>
      <tr><td class="left"> * than proportional to any data stream.</td><td> </td><td class="right"> * than proportional to any data stream.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0030"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_pool_t *) </span>serf_request_get_pool(</td><td> </td><td class="rblock"><span class="insert">apr_pool_t *</span>serf_request_get_pool(</td></tr>
      <tr><td class="left">    const serf_request_t *request);</td><td> </td><td class="right">    const serf_request_t *request);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the bucket allocator associated with @a request.</td><td> </td><td class="right"> * Return the bucket allocator associated with @a request.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0031"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_alloc_t *) </span>serf_request_get_alloc(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_alloc_t *</span>serf_request_get_alloc(</td></tr>
      <tr><td class="left">    const serf_request_t *request);</td><td> </td><td class="right">    const serf_request_t *request);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the connection associated with @a request.</td><td> </td><td class="right"> * Return the connection associated with @a request.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0032"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_connection_t *) </span>serf_request_get_conn(</td><td> </td><td class="rblock"><span class="insert">serf_connection_t *</span>serf_request_get_conn(</td></tr>
      <tr><td class="left">    const serf_request_t *request);</td><td> </td><td class="right">    const serf_request_t *request);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Update the @a handler and @a handler_baton for this @a request.</td><td> </td><td class="right"> * Update the @a handler and @a handler_baton for this @a request.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This can be called after the request has started processing -</td><td> </td><td class="right"> * This can be called after the request has started processing -</td></tr>
      <tr><td class="left"> * subsequent data will be delivered to this new handler.</td><td> </td><td class="right"> * subsequent data will be delivered to this new handler.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0033"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_request_set_handler(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_request_set_handler(</td></tr>
      <tr><td class="left">    serf_request_t *request,</td><td> </td><td class="right">    serf_request_t *request,</td></tr>
      <tr><td class="left">    const serf_response_handler_t handler,</td><td> </td><td class="right">    const serf_response_handler_t handler,</td></tr>
      <tr><td class="left">    const void **handler_baton);</td><td> </td><td class="right">    const void **handler_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Configure proxy server settings, to be used by all connections associate
d</td><td> </td><td class="right"> * Configure proxy server settings, to be used by all connections associate
d</td></tr>
      <tr><td class="left"> * with the @a ctx serf context.</td><td> </td><td class="right"> * with the @a ctx serf context.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The next connection will be created to connect to the proxy server</td><td> </td><td class="right"> * The next connection will be created to connect to the proxy server</td></tr>
      <tr><td class="left"> * specified by @a address. The address must live at least as long as the</td><td> </td><td class="right"> * specified by @a address. The address must live at least as long as the</td></tr>
      <tr><td class="left"> * serf context.</td><td> </td><td class="right"> * serf context.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0034"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_config_proxy(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_config_proxy(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_sockaddr_t *address);</td><td> </td><td class="right">    apr_sockaddr_t *address);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Supported authentication types. */</td><td> </td><td class="right">/* Supported authentication types. */</td></tr>
      <tr><td class="left">#define SERF_AUTHN_NONE      0x00</td><td> </td><td class="right">#define SERF_AUTHN_NONE      0x00</td></tr>
      <tr><td class="left">#define SERF_AUTHN_BASIC     0x01</td><td> </td><td class="right">#define SERF_AUTHN_BASIC     0x01</td></tr>
      <tr><td class="left">#define SERF_AUTHN_DIGEST    0x02</td><td> </td><td class="right">#define SERF_AUTHN_DIGEST    0x02</td></tr>
      <tr><td class="left">#define SERF_AUTHN_NTLM      0x04</td><td> </td><td class="right">#define SERF_AUTHN_NTLM      0x04</td></tr>
      <tr><td class="left">#define SERF_AUTHN_NEGOTIATE 0x08</td><td> </td><td class="right">#define SERF_AUTHN_NEGOTIATE 0x08</td></tr>
      <tr><td class="left">#define SERF_AUTHN_ALL       0xFF</td><td> </td><td class="right">#define SERF_AUTHN_ALL       0xFF</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Define the authentication handlers that serf will try on incoming reques
ts.</td><td> </td><td class="right"> * Define the authentication handlers that serf will try on incoming reques
ts.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0035"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_config_authn_types(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_config_authn_types(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    int authn_types);</td><td> </td><td class="right">    int authn_types);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set the credentials callback handler.</td><td> </td><td class="right"> * Set the credentials callback handler.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0036"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_config_credentials_callback(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_config_credentials_callback(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    serf_credentials_callback_t cred_cb);</td><td> </td><td class="right">    serf_credentials_callback_t cred_cb);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ### maybe some connection control functions for flood? */</td><td> </td><td class="right">/* ### maybe some connection control functions for flood? */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*** Special bucket creation functions ***/</td><td> </td><td class="right">/*** Special bucket creation functions ***/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a bucket of type 'socket bucket'.</td><td> </td><td class="right"> * Create a bucket of type 'socket bucket'.</td></tr>
      <tr><td class="left"> * This is basically a wrapper around @a serf_bucket_socket_create, which</td><td> </td><td class="right"> * This is basically a wrapper around @a serf_bucket_socket_create, which</td></tr>
      <tr><td class="left"> * initializes the bucket using connection and/or context specific settings
.</td><td> </td><td class="right"> * initializes the bucket using connection and/or context specific settings
.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0037"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_context_bucket_socket_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_context_bucket_socket_create(</td></tr>
      <tr><td class="left">    serf_context_t *ctx,</td><td> </td><td class="right">    serf_context_t *ctx,</td></tr>
      <tr><td class="left">    apr_socket_t *skt,</td><td> </td><td class="right">    apr_socket_t *skt,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a bucket of type 'request bucket'.</td><td> </td><td class="right"> * Create a bucket of type 'request bucket'.</td></tr>
      <tr><td class="left"> * This is basically a wrapper around @a serf_bucket_request_create, which</td><td> </td><td class="right"> * This is basically a wrapper around @a serf_bucket_request_create, which</td></tr>
      <tr><td class="left"> * initializes the bucket using request, connection and/or context specific</td><td> </td><td class="right"> * initializes the bucket using request, connection and/or context specific</td></tr>
      <tr><td class="left"> * settings.</td><td> </td><td class="right"> * settings.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will set following header(s):</td><td> </td><td class="right"> * This function will set following header(s):</td></tr>
      <tr><td class="left"> * - Host: if the connection was created with @a serf_connection_create2.</td><td> </td><td class="right"> * - Host: if the connection was created with @a serf_connection_create2.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0038"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_request_bucket_request_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_request_bucket_request_create(</td></tr>
      <tr><td class="left">    serf_request_t *request,</td><td> </td><td class="right">    serf_request_t *request,</td></tr>
      <tr><td class="left">    const char *method,</td><td> </td><td class="right">    const char *method,</td></tr>
      <tr><td class="left">    const char *uri,</td><td> </td><td class="right">    const char *uri,</td></tr>
      <tr><td class="left">    serf_bucket_t *body,</td><td> </td><td class="right">    serf_bucket_t *body,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @} */</td><td> </td><td class="right">/** @} */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @defgroup serf buckets</td><td> </td><td class="right"> * @defgroup serf buckets</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 893<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 909<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define SERF_BUCKET_CHECK(b, btype) ((b)-&gt;type == &amp;serf_bucket_type_ ## bty
pe)</td><td> </td><td class="right">#define SERF_BUCKET_CHECK(b, btype) ((b)-&gt;type == &amp;serf_bucket_type_ ## bty
pe)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Notification callback for a block that was not returned to the bucket</td><td> </td><td class="right"> * Notification callback for a block that was not returned to the bucket</td></tr>
      <tr><td class="left"> * allocator when its pool was destroyed.</td><td> </td><td class="right"> * allocator when its pool was destroyed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The block of memory is given by @a block. The baton provided when the</td><td> </td><td class="right"> * The block of memory is given by @a block. The baton provided when the</td></tr>
      <tr><td class="left"> * allocator was constructed is passed as @a unfreed_baton.</td><td> </td><td class="right"> * allocator was constructed is passed as @a unfreed_baton.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0039"></tr>
      <tr><td class="lblock">typedef void <span class="delete">(*serf_unfreed_func_t)(void</span> *unfreed_baton, void *block);</td><td> </td><td class="rblock">typedef void <span class="insert">(*serf_unfreed_func_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void</span> *unfreed_baton,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    void *block);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new allocator for buckets.</td><td> </td><td class="right"> * Create a new allocator for buckets.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * All buckets are associated with a serf bucket allocator. This allocator</td><td> </td><td class="right"> * All buckets are associated with a serf bucket allocator. This allocator</td></tr>
      <tr><td class="left"> * will be created within @a pool and will be destroyed when that pool is</td><td> </td><td class="right"> * will be created within @a pool and will be destroyed when that pool is</td></tr>
      <tr><td class="left"> * cleared or destroyed.</td><td> </td><td class="right"> * cleared or destroyed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * When the allocator is destroyed, if any allocations were not explicitly</td><td> </td><td class="right"> * When the allocator is destroyed, if any allocations were not explicitly</td></tr>
      <tr><td class="left"> * returned (by calling serf_bucket_mem_free), then the @a unfreed callback</td><td> </td><td class="right"> * returned (by calling serf_bucket_mem_free), then the @a unfreed callback</td></tr>
      <tr><td class="left"> * will be invoked for each block. @a unfreed_baton will be passed to the</td><td> </td><td class="right"> * will be invoked for each block. @a unfreed_baton will be passed to the</td></tr>
      <tr><td class="left"> * callback.</td><td> </td><td class="right"> * callback.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If @a unfreed is NULL, then the library will invoke the abort() stdlib</td><td> </td><td class="right"> * If @a unfreed is NULL, then the library will invoke the abort() stdlib</td></tr>
      <tr><td class="left"> * call. Any failure to return memory is a bug in the application, and an</td><td> </td><td class="right"> * call. Any failure to return memory is a bug in the application, and an</td></tr>
      <tr><td class="left"> * abort can assist with determining what kinds of memory were not freed.</td><td> </td><td class="right"> * abort can assist with determining what kinds of memory were not freed.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0040"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_alloc_t *) </span>serf_bucket_allocator_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_alloc_t *</span>serf_bucket_allocator_create(</td></tr>
      <tr><td class="left">    apr_pool_t *pool,</td><td> </td><td class="right">    apr_pool_t *pool,</td></tr>
      <tr><td class="left">    serf_unfreed_func_t unfreed,</td><td> </td><td class="right">    serf_unfreed_func_t unfreed,</td></tr>
      <tr><td class="left">    void *unfreed_baton);</td><td> </td><td class="right">    void *unfreed_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the pool that was used for this @a allocator.</td><td> </td><td class="right"> * Return the pool that was used for this @a allocator.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * WARNING: the use of this pool for allocations requires a very</td><td> </td><td class="right"> * WARNING: the use of this pool for allocations requires a very</td></tr>
      <tr><td class="left"> *   detailed understanding of pool behaviors, the bucket system,</td><td> </td><td class="right"> *   detailed understanding of pool behaviors, the bucket system,</td></tr>
      <tr><td class="left"> *   and knowledge of the bucket's use within the overall pattern</td><td> </td><td class="right"> *   and knowledge of the bucket's use within the overall pattern</td></tr>
      <tr><td class="left"> *   of request/response behavior.</td><td> </td><td class="right"> *   of request/response behavior.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * See design-guide.txt for more information about pool usage.</td><td> </td><td class="right"> * See design-guide.txt for more information about pool usage.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0041"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_pool_t *) </span>serf_bucket_allocator_get_pool(</td><td> </td><td class="rblock"><span class="insert">apr_pool_t *</span>serf_bucket_allocator_get_pool(</td></tr>
      <tr><td class="left">    const serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    const serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Utility structure for reading a complete line of input from a bucket.</td><td> </td><td class="right"> * Utility structure for reading a complete line of input from a bucket.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Since it is entirely possible for a line to be broken by APR_EAGAIN,</td><td> </td><td class="right"> * Since it is entirely possible for a line to be broken by APR_EAGAIN,</td></tr>
      <tr><td class="left"> * this structure can be used to accumulate the data until a complete line</td><td> </td><td class="right"> * this structure can be used to accumulate the data until a complete line</td></tr>
      <tr><td class="left"> * has been read from a bucket.</td><td> </td><td class="right"> * has been read from a bucket.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-10" class="change" ><th><small>skipping to change at</small><a href="#part-10"><em> line 963<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-10"><em> line 981<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    apr_size_t used;</td><td> </td><td class="right">    apr_size_t used;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /* The line is read into this buffer, minus CR/LF */</td><td> </td><td class="right">    /* The line is read into this buffer, minus CR/LF */</td></tr>
      <tr><td class="left">    char line[SERF_LINEBUF_LIMIT];</td><td> </td><td class="right">    char line[SERF_LINEBUF_LIMIT];</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} serf_linebuf_t;</td><td> </td><td class="right">} serf_linebuf_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Initialize the @a linebuf structure.</td><td> </td><td class="right"> * Initialize the @a linebuf structure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0042"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_linebuf_init(serf_linebuf_t *linebuf);</td><td> </td><td class="rblock"><span class="insert">void</span> serf_linebuf_init(serf_linebuf_t *linebuf);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Fetch a line of text from @a bucket, accumulating the line into</td><td> </td><td class="right"> * Fetch a line of text from @a bucket, accumulating the line into</td></tr>
      <tr><td class="left"> * @a linebuf. @a acceptable specifies the types of newlines which are</td><td> </td><td class="right"> * @a linebuf. @a acceptable specifies the types of newlines which are</td></tr>
      <tr><td class="left"> * acceptable for this fetch.</td><td> </td><td class="right"> * acceptable for this fetch.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ### we should return a data/len pair so that we can avoid a copy,</td><td> </td><td class="right"> * ### we should return a data/len pair so that we can avoid a copy,</td></tr>
      <tr><td class="left"> * ### rather than having callers look into our state and line buffer.</td><td> </td><td class="right"> * ### rather than having callers look into our state and line buffer.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0043"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_linebuf_fetch(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_linebuf_fetch(</td></tr>
      <tr><td class="left">    serf_linebuf_t *linebuf,</td><td> </td><td class="right">    serf_linebuf_t *linebuf,</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    int acceptable);</td><td> </td><td class="right">    int acceptable);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @} */</td><td> </td><td class="right">/** @} */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Internal functions for bucket use and lifecycle tracking */</td><td> </td><td class="right">/* Internal functions for bucket use and lifecycle tracking */</td></tr>
      <tr id="diff0044"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_debug__record_read(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_debug__record_read(</td></tr>
      <tr><td class="left">    const serf_bucket_t *bucket,</td><td> </td><td class="right">    const serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    apr_status_t status);</td><td> </td><td class="right">    apr_status_t status);</td></tr>
      <tr id="diff0045"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_debug__entered_loop(serf_bucket_alloc_t *allocator)</span></td><td> </td><td class="rblock"><span class="insert">void serf_debug__entered_loop(</span></td></tr>
      <tr><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t</span> *allocator);</td></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_debug__closed_conn(serf_bucket_alloc_t</span> *allocator);</td><td> </td><td class="rblock"><span class="insert">void serf_debug__closed_conn(</span></td></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_debug__bucket_destroy(const</span> serf_bucket_t *bucket);</td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_debug__bucket_alloc_check(serf_bucket_alloc_t *allo</span></td><td> </td><td class="rblock"><span class="insert">void serf_debug__bucket_destroy(</span></td></tr>
      <tr><td class="lblock"><span class="delete">cator);</span></td><td> </td><td class="rblock"><span class="insert">    const</span> serf_bucket_t *bucket);</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void serf_debug__bucket_alloc_check(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Version info */</td><td> </td><td class="right">/* Version info */</td></tr>
      <tr><td class="left">#define SERF_MAJOR_VERSION 0</td><td> </td><td class="right">#define SERF_MAJOR_VERSION 0</td></tr>
      <tr id="diff0046"></tr>
      <tr><td class="lblock">#define SERF_MINOR_VERSION <span class="delete">5</span></td><td> </td><td class="rblock">#define SERF_MINOR_VERSION <span class="insert">7</span></td></tr>
      <tr><td class="left">#define SERF_PATCH_VERSION 0</td><td> </td><td class="right">#define SERF_PATCH_VERSION 0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Version number string */</td><td> </td><td class="right">/* Version number string */</td></tr>
      <tr><td class="left">#define SERF_VERSION_STRING APR_STRINGIFY(SERF_MAJOR_VERSION) "." \</td><td> </td><td class="right">#define SERF_VERSION_STRING APR_STRINGIFY(SERF_MAJOR_VERSION) "." \</td></tr>
      <tr><td class="left">                            APR_STRINGIFY(SERF_MINOR_VERSION) "." \</td><td> </td><td class="right">                            APR_STRINGIFY(SERF_MINOR_VERSION) "." \</td></tr>
      <tr><td class="left">                            APR_STRINGIFY(SERF_PATCH_VERSION)</td><td> </td><td class="right">                            APR_STRINGIFY(SERF_PATCH_VERSION)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check at compile time if the Serf version is at least a certain</td><td> </td><td class="right"> * Check at compile time if the Serf version is at least a certain</td></tr>
      <tr><td class="left"> * level.</td><td> </td><td class="right"> * level.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-11" class="change" ><th><small>skipping to change at</small><a href="#part-11"><em> line 1023<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-11"><em> line 1045<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">            (patch) &lt;= SERF_PATCH_VERSION))</td><td> </td><td class="right">            (patch) &lt;= SERF_PATCH_VERSION))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Returns the version of the library the application has linked/loaded.</td><td> </td><td class="right"> * Returns the version of the library the application has linked/loaded.</td></tr>
      <tr><td class="left"> * Values are returned in @a major, @a minor, and @a patch.</td><td> </td><td class="right"> * Values are returned in @a major, @a minor, and @a patch.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Applications will want to use this function to verify compatibility,</td><td> </td><td class="right"> * Applications will want to use this function to verify compatibility,</td></tr>
      <tr><td class="left"> * expecially while serf has not reached a 1.0 milestone. APIs and</td><td> </td><td class="right"> * expecially while serf has not reached a 1.0 milestone. APIs and</td></tr>
      <tr><td class="left"> * semantics may change drastically until the library hits 1.0.</td><td> </td><td class="right"> * semantics may change drastically until the library hits 1.0.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0047"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_lib_version(int</span> *major, int *minor, int *patch);</td><td> </td><td class="rblock"><span class="insert">void serf_lib_version(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int</span> *major,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    int *minor,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    int *patch);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> * Every user of serf will want to deal with our various bucket types.</td><td> </td><td class="right"> * Every user of serf will want to deal with our various bucket types.</td></tr>
      <tr><td class="left"> * Go ahead and include that header right now.</td><td> </td><td class="right"> * Go ahead and include that header right now.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note: make sure this occurs outside of the C++ namespace block</td><td> </td><td class="right"> * Note: make sure this occurs outside of the C++ namespace block</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 47 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>108 lines changed or deleted</i></th><th><i> </i></th><th><i>123 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;serf_bucket_types.h (0.4.0)&nbsp;</th><th> </th><th>&nbsp;serf_bucket_types.h (0.7.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 27<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 27<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define SERF_BUCKET_TYPES_H</td><td> </td><td class="right">#define SERF_BUCKET_TYPES_H</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;apr_mmap.h&gt;</td><td> </td><td class="right">#include &lt;apr_mmap.h&gt;</td></tr>
      <tr><td class="left">#include &lt;apr_hash.h&gt;</td><td> </td><td class="right">#include &lt;apr_hash.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* this header and serf.h refer to each other, so take a little extra care 
*/</td><td> </td><td class="right">/* this header and serf.h refer to each other, so take a little extra care 
*/</td></tr>
      <tr><td class="left">#ifndef SERF_H</td><td> </td><td class="right">#ifndef SERF_H</td></tr>
      <tr><td class="left">#include "serf.h"</td><td> </td><td class="right">#include "serf.h"</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"><span class="delete">#include "serf_declare.h"</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @file serf_bucket_types.h</td><td> </td><td class="right"> * @file serf_bucket_types.h</td></tr>
      <tr><td class="left"> * @brief serf-supported bucket types</td><td> </td><td class="right"> * @brief serf-supported bucket types</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/* ### this whole file needs docco ... */</td><td> </td><td class="right">/* ### this whole file needs docco ... */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_request;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_request;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_REQUEST(b) SERF_BUCKET_CHECK((b), request)</td><td> </td><td class="right">#define SERF_BUCKET_IS_REQUEST(b) SERF_BUCKET_CHECK((b), request)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_request_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_request_create(</td></tr>
      <tr><td class="left">    const char *method,</td><td> </td><td class="right">    const char *method,</td></tr>
      <tr><td class="left">    const char *URI,</td><td> </td><td class="right">    const char *URI,</td></tr>
      <tr><td class="left">    serf_bucket_t *body,</td><td> </td><td class="right">    serf_bucket_t *body,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_request_get_headers(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_request_get_headers(</td></tr>
      <tr><td class="left">    serf_bucket_t *request);</td><td> </td><td class="right">    serf_bucket_t *request);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_bucket_request_become(serf_bucket_t</span> *bucket,</td><td> </td><td class="rblock"><span class="insert">void serf_bucket_request_become(</span></td></tr>
      <tr><td class="lblock">                                              const char *method,</td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *bucket,</td></tr>
      <tr><td class="lblock">                                              const char *uri,</td><td> </td><td class="rblock">    const char *method,</td></tr>
      <tr><td class="lblock">                                              serf_bucket_t *body);</td><td> </td><td class="rblock">    const char *uri,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    serf_bucket_t *body);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Sets the root url of the remote host. If this request contains a relativ
e</td><td> </td><td class="right"> * Sets the root url of the remote host. If this request contains a relativ
e</td></tr>
      <tr><td class="left"> * url, it will be prefixed with the root url to form an absolute url.</td><td> </td><td class="right"> * url, it will be prefixed with the root url to form an absolute url.</td></tr>
      <tr><td class="left"> * @a bucket is the request bucket. @a root_url is the absolute url of the</td><td> </td><td class="right"> * @a bucket is the request bucket. @a root_url is the absolute url of the</td></tr>
      <tr><td class="left"> * root of the remote host, without the closing '/'.</td><td> </td><td class="right"> * root of the remote host, without the closing '/'.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_bucket_request_set_root(serf_bucket_t</span> *bucket,</td><td> </td><td class="rblock"><span class="insert">void serf_bucket_request_set_root(</span></td></tr>
      <tr><td class="lblock">                                                const char *root_url);</td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *bucket,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    const char *root_url);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_response
</span>;</td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_response</span>;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_RESPONSE(b) SERF_BUCKET_CHECK((b), response)</td><td> </td><td class="right">#define SERF_BUCKET_IS_RESPONSE(b) SERF_BUCKET_CHECK((b), response)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_response_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_response_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define SERF_HTTP_VERSION(major, minor)  ((major) * 1000 + (minor))</td><td> </td><td class="right">#define SERF_HTTP_VERSION(major, minor)  ((major) * 1000 + (minor))</td></tr>
      <tr><td class="left">#define SERF_HTTP_11 SERF_HTTP_VERSION(1, 1)</td><td> </td><td class="right">#define SERF_HTTP_11 SERF_HTTP_VERSION(1, 1)</td></tr>
      <tr><td class="left">#define SERF_HTTP_10 SERF_HTTP_VERSION(1, 0)</td><td> </td><td class="right">#define SERF_HTTP_10 SERF_HTTP_VERSION(1, 0)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td class="left">    int version;</td><td> </td><td class="right">    int version;</td></tr>
      <tr><td class="left">    int code;</td><td> </td><td class="right">    int code;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 95<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 95<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the Status-Line information, if available. This function</td><td> </td><td class="right"> * Return the Status-Line information, if available. This function</td></tr>
      <tr><td class="left"> * works like other bucket read functions: it may return APR_EAGAIN or</td><td> </td><td class="right"> * works like other bucket read functions: it may return APR_EAGAIN or</td></tr>
      <tr><td class="left"> * APR_EOF to signal the state of the bucket for reading. A return</td><td> </td><td class="right"> * APR_EOF to signal the state of the bucket for reading. A return</td></tr>
      <tr><td class="left"> * value of APR_SUCCESS will always indicate that status line</td><td> </td><td class="right"> * value of APR_SUCCESS will always indicate that status line</td></tr>
      <tr><td class="left"> * information was returned; for other return values the caller must</td><td> </td><td class="right"> * information was returned; for other return values the caller must</td></tr>
      <tr><td class="left"> * check the version field in @a sline. A value of 0 means that the</td><td> </td><td class="right"> * check the version field in @a sline. A value of 0 means that the</td></tr>
      <tr><td class="left"> * data is not (yet) present.</td><td> </td><td class="right"> * data is not (yet) present.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_bucket_response_status(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_bucket_response_status(</td></tr>
      <tr><td class="left">    serf_bucket_t *bkt,</td><td> </td><td class="right">    serf_bucket_t *bkt,</td></tr>
      <tr><td class="left">    serf_status_line *sline);</td><td> </td><td class="right">    serf_status_line *sline);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Wait for the HTTP headers to be processed for a @a response.</td><td> </td><td class="right"> * Wait for the HTTP headers to be processed for a @a response.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If the headers are available, APR_SUCCESS is returned.</td><td> </td><td class="right"> * If the headers are available, APR_SUCCESS is returned.</td></tr>
      <tr><td class="left"> * If the headers aren't available, APR_EAGAIN is returned.</td><td> </td><td class="right"> * If the headers aren't available, APR_EAGAIN is returned.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_bucket_response_wait_for_headers(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_bucket_response_wait_for_headers(</td></tr>
      <tr><td class="left">    serf_bucket_t *response);</td><td> </td><td class="right">    serf_bucket_t *response);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Get the headers bucket for @a response.</td><td> </td><td class="right"> * Get the headers bucket for @a response.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_response_get_headers(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_response_get_headers(</td></tr>
      <tr><td class="left">    serf_bucket_t *response);</td><td> </td><td class="right">    serf_bucket_t *response);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Advise the response @a bucket that this was from a HEAD request and</td><td> </td><td class="right"> * Advise the response @a bucket that this was from a HEAD request and</td></tr>
      <tr><td class="left"> * that it should not expect to see a response body.</td><td> </td><td class="right"> * that it should not expect to see a response body.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_bucket_response_set_head(serf_bucket_t</span> *bucket);</td><td> </td><td class="rblock"><span class="insert">void serf_bucket_response_set_head(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_bwtp_fra
</span>me;</td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_bwtp_fra</span>me;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_BWTP_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_frame)</td><td> </td><td class="right">#define SERF_BUCKET_IS_BWTP_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_frame)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_bwtp_inc
</span>oming_frame;</td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_bwtp_inc</span>oming_frame;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_BWTP_INCOMING_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_i
ncoming_frame)</td><td> </td><td class="right">#define SERF_BUCKET_IS_BWTP_INCOMING_FRAME(b) SERF_BUCKET_CHECK((b), bwtp_i
ncoming_frame)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(int) serf_bucket_bwtp_frame_get_channel(serf_bucket_t</span> *hdr);</td><td> </td><td class="rblock"><span class="insert">int serf_bucket_bwtp_frame_get_channel(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *hdr);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(int) serf_bucket_bwtp_frame_get_type(serf_bucket_t</span> *hdr);</td><td> </td><td class="rblock"><span class="insert">int serf_bucket_bwtp_frame_get_type(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *hdr);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(const</span> char <span class="delete">*) serf_bucket_bwtp_frame_get_phrase(serf_bucket_t</span> </td><td> </td><td class="rblock"><span class="insert">const</span> char <span class="insert">*serf_bucket_bwtp_frame_get_phrase(</span></td></tr>
      <tr><td class="lblock">*hdr);</td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *hdr);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_bwtp_frame_get_headers(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_bwtp_frame_get_headers(</td></tr>
      <tr><td class="left">    serf_bucket_t *hdr);</td><td> </td><td class="right">    serf_bucket_t *hdr);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_bwtp_channel_open(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_bwtp_channel_open(</td></tr>
      <tr><td class="left">    int channel,</td><td> </td><td class="right">    int channel,</td></tr>
      <tr><td class="left">    const char *URI,</td><td> </td><td class="right">    const char *URI,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_bwtp_channel_close(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_bwtp_channel_close(</td></tr>
      <tr><td class="left">    int channel,</td><td> </td><td class="right">    int channel,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_bwtp_header_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_bwtp_header_create(</td></tr>
      <tr><td class="left">    int channel,</td><td> </td><td class="right">    int channel,</td></tr>
      <tr><td class="left">    const char *phrase,</td><td> </td><td class="right">    const char *phrase,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_bwtp_message_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_bwtp_message_create(</td></tr>
      <tr><td class="left">    int channel,</td><td> </td><td class="right">    int channel,</td></tr>
      <tr><td class="left">    serf_bucket_t *body,</td><td> </td><td class="right">    serf_bucket_t *body,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_bwtp_incoming_frame_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_bwtp_incoming_frame_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *bkt,</td><td> </td><td class="right">    serf_bucket_t *bkt,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_bucket_bwtp_incoming_frame_wait_for_headers
</span>(</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_bucket_bwtp_incoming_frame_wait_for_headers</span>(</td></tr>
      <tr><td class="left">    serf_bucket_t *bkt);</td><td> </td><td class="right">    serf_bucket_t *bkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0025"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_aggregat
</span>e;</td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_aggregat</span>e;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_AGGREGATE(b) SERF_BUCKET_CHECK((b), aggregate)</td><td> </td><td class="right">#define SERF_BUCKET_IS_AGGREGATE(b) SERF_BUCKET_CHECK((b), aggregate)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0026"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef apr_status_t (*serf_bucket_aggregate_eof_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *baton,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *aggregate_bucket);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** serf_bucket_aggregate_cleanup will instantly destroy all buckets in</td><td> </td><td class="right">/** serf_bucket_aggregate_cleanup will instantly destroy all buckets in</td></tr>
      <tr><td class="left">    the aggregate bucket that have been read completely. Whereas normally,</td><td> </td><td class="right">    the aggregate bucket that have been read completely. Whereas normally,</td></tr>
      <tr><td class="left">    these buckets are destroyed on every read operation. */</td><td> </td><td class="right">    these buckets are destroyed on every read operation. */</td></tr>
      <tr id="diff0027"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_aggregate_cleanup(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_aggregate_cleanup(</td></tr>
      <tr><td class="lblock">    serf_bucket_t *bucket, serf_bucket_alloc_t *allocator);</td><td> </td><td class="rblock">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0028"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_aggregate_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_aggregate_create(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0029"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Creates a stream bucket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   A stream bucket is like an aggregate bucket, but:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - it doesn't destroy its child buckets on cleanup</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - one can always keep adding child buckets, the handler FN should return</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     APR_EOF when no more buckets will be added.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Note: keep this factory function internal for now. If it turns out this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  bucket type is useful outside serf, we should make it an actual separate</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  type.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf__bucket_stream_create(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t *allocator,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_aggregate_eof_t fn,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *baton);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Transform @a bucket in-place into an aggregate bucket. */</td><td> </td><td class="right">/** Transform @a bucket in-place into an aggregate bucket. */</td></tr>
      <tr id="diff0030"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_bucket_aggregate_become(serf_bucket_t</span> *bucket);</td><td> </td><td class="rblock"><span class="insert">void serf_bucket_aggregate_become(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0031"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_aggregate_prepend(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_aggregate_prepend(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    serf_bucket_t *prepend_bucket);</td><td> </td><td class="right">    serf_bucket_t *prepend_bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0032"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_aggregate_append(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_aggregate_append(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    serf_bucket_t *append_bucket);</td><td> </td><td class="right">    serf_bucket_t *append_bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0033"></tr>
      <tr><td class="lblock"><span class="delete">typedef apr_status_t (*serf_bucket_aggregate_eof_t)(void *baton, serf_bucke</span></td><td> </td><td class="rblock"><span class="insert">void serf_bucket_aggregate_hold_open(</span></td></tr>
      <tr><td class="lblock"><span class="delete">t_t *aggregate_bucket);</span></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *aggregate_bucket,</span></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_aggregate_eof_t</span> fn,</td></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_bucket_aggregate_hold_open(serf_bucket_t *aggregate</span></td><td> </td><td class="rblock">    void *baton);</td></tr>
      <tr><td class="lblock"><span class="delete">_bucket,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                                                   serf_bucket_aggregate_eo</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">f_t</span> fn,</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                   void *baton);</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0034"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_aggregate_prepend_iovec(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_aggregate_prepend_iovec(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    struct iovec *vecs,</td><td> </td><td class="right">    struct iovec *vecs,</td></tr>
      <tr><td class="left">    int vecs_count);</td><td> </td><td class="right">    int vecs_count);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0035"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_aggregate_append_iovec(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_aggregate_append_iovec(</td></tr>
      <tr><td class="left">    serf_bucket_t *aggregate_bucket,</td><td> </td><td class="right">    serf_bucket_t *aggregate_bucket,</td></tr>
      <tr><td class="left">    struct iovec *vecs,</td><td> </td><td class="right">    struct iovec *vecs,</td></tr>
      <tr><td class="left">    int vecs_count);</td><td> </td><td class="right">    int vecs_count);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0036"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_file;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_file;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_FILE(b) SERF_BUCKET_CHECK((b), file)</td><td> </td><td class="right">#define SERF_BUCKET_IS_FILE(b) SERF_BUCKET_CHECK((b), file)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0037"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_file_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_file_create(</td></tr>
      <tr><td class="left">    apr_file_t *file,</td><td> </td><td class="right">    apr_file_t *file,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0038"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_file_t *) serf_bucket_file_borrow(serf_bucket_t *bkt);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0039"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_socket;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_socket;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_SOCKET(b) SERF_BUCKET_CHECK((b), socket)</td><td> </td><td class="right">#define SERF_BUCKET_IS_SOCKET(b) SERF_BUCKET_CHECK((b), socket)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0040"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_socket_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_socket_create(</td></tr>
      <tr><td class="left">    apr_socket_t *skt,</td><td> </td><td class="right">    apr_socket_t *skt,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Call @a progress_func every time bytes are read from the socket, pass</td><td> </td><td class="right"> * Call @a progress_func every time bytes are read from the socket, pass</td></tr>
      <tr><td class="left"> * the number of bytes read.</td><td> </td><td class="right"> * the number of bytes read.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * When using serf's bytes read &amp; written progress indicator, pass</td><td> </td><td class="right"> * When using serf's bytes read &amp; written progress indicator, pass</td></tr>
      <tr><td class="left"> * @a serf_context_progress_delta for progress_func and the serf_context fo
r</td><td> </td><td class="right"> * @a serf_context_progress_delta for progress_func and the serf_context fo
r</td></tr>
      <tr><td class="left"> * progress_baton.</td><td> </td><td class="right"> * progress_baton.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0041"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_socket_set_read_progress_cb(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_socket_set_read_progress_cb(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    const serf_progress_t progress_func,</td><td> </td><td class="right">    const serf_progress_t progress_func,</td></tr>
      <tr><td class="left">    void *progress_baton);</td><td> </td><td class="right">    void *progress_baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0042"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_simple;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_simple;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_SIMPLE(b) SERF_BUCKET_CHECK((b), simple)</td><td> </td><td class="right">#define SERF_BUCKET_IS_SIMPLE(b) SERF_BUCKET_CHECK((b), simple)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0043"></tr>
      <tr><td class="lblock">typedef void <span class="delete">(*serf_simple_freefunc_t)(void</span> *baton, const char *data);</td><td> </td><td class="rblock">typedef void <span class="insert">(*serf_simple_freefunc_t)(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void</span> *baton,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    const char *data);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0044"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) serf_bucket_simple_create(</span></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf_bucket_simple_create(</span></td></tr>
      <tr><td class="lblock">    const char *data, apr_size_t len,</td><td> </td><td class="rblock">    const char *data,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t len,</td></tr>
      <tr><td class="left">    serf_simple_freefunc_t freefunc,</td><td> </td><td class="right">    serf_simple_freefunc_t freefunc,</td></tr>
      <tr><td class="left">    void *freefunc_baton,</td><td> </td><td class="right">    void *freefunc_baton,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Equivalent to serf_bucket_simple_create, except that the bucket takes</td><td> </td><td class="right"> * Equivalent to serf_bucket_simple_create, except that the bucket takes</td></tr>
      <tr><td class="left"> * ownership of a private copy of the data.</td><td> </td><td class="right"> * ownership of a private copy of the data.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0045"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) serf_bucket_simple_copy_create(</span></td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *serf_bucket_simple_copy_create(</span></td></tr>
      <tr><td class="lblock">    const char *data, apr_size_t len,</td><td> </td><td class="rblock">    const char *data,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t len,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define SERF_BUCKET_SIMPLE_STRING(s,a) \</td><td> </td><td class="right">#define SERF_BUCKET_SIMPLE_STRING(s,a) \</td></tr>
      <tr><td class="left">    serf_bucket_simple_create(s, strlen(s), NULL, NULL, a);</td><td> </td><td class="right">    serf_bucket_simple_create(s, strlen(s), NULL, NULL, a);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define SERF_BUCKET_SIMPLE_STRING_LEN(s,l,a) \</td><td> </td><td class="right">#define SERF_BUCKET_SIMPLE_STRING_LEN(s,l,a) \</td></tr>
      <tr><td class="left">    serf_bucket_simple_create(s, l, NULL, NULL, a);</td><td> </td><td class="right">    serf_bucket_simple_create(s, l, NULL, NULL, a);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Note: apr_mmap_t is always defined, but if APR doesn't have mmaps, then</td><td> </td><td class="right">/* Note: apr_mmap_t is always defined, but if APR doesn't have mmaps, then</td></tr>
      <tr><td class="left">   the caller can never create an apr_mmap_t to pass to this function. */</td><td> </td><td class="right">   the caller can never create an apr_mmap_t to pass to this function. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0046"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_mmap;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_mmap;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_MMAP(b) SERF_BUCKET_CHECK((b), mmap)</td><td> </td><td class="right">#define SERF_BUCKET_IS_MMAP(b) SERF_BUCKET_CHECK((b), mmap)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0047"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_mmap_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_mmap_create(</td></tr>
      <tr><td class="left">    apr_mmap_t *mmap,</td><td> </td><td class="right">    apr_mmap_t *mmap,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0048"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_headers;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_headers;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_HEADERS(b) SERF_BUCKET_CHECK((b), headers)</td><td> </td><td class="right">#define SERF_BUCKET_IS_HEADERS(b) SERF_BUCKET_CHECK((b), headers)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0049"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_headers_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_headers_create(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set, default: value copied.</td><td> </td><td class="right"> * Set, default: value copied.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Set the specified @a header within the bucket, copying the @a value</td><td> </td><td class="right"> * Set the specified @a header within the bucket, copying the @a value</td></tr>
      <tr><td class="left"> * into space from this bucket's allocator. The header is NOT copied,</td><td> </td><td class="right"> * into space from this bucket's allocator. The header is NOT copied,</td></tr>
      <tr><td class="left"> * so it should remain in scope at least as long as the bucket.</td><td> </td><td class="right"> * so it should remain in scope at least as long as the bucket.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0050"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_headers_set(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_headers_set(</td></tr>
      <tr><td class="left">    serf_bucket_t *headers_bucket,</td><td> </td><td class="right">    serf_bucket_t *headers_bucket,</td></tr>
      <tr><td class="left">    const char *header,</td><td> </td><td class="right">    const char *header,</td></tr>
      <tr><td class="left">    const char *value);</td><td> </td><td class="right">    const char *value);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set, copies: header and value copied.</td><td> </td><td class="right"> * Set, copies: header and value copied.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Copy the specified @a header and @a value into the bucket, using space</td><td> </td><td class="right"> * Copy the specified @a header and @a value into the bucket, using space</td></tr>
      <tr><td class="left"> * from this bucket's allocator.</td><td> </td><td class="right"> * from this bucket's allocator.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0051"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_headers_setc(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_headers_setc(</td></tr>
      <tr><td class="left">    serf_bucket_t *headers_bucket,</td><td> </td><td class="right">    serf_bucket_t *headers_bucket,</td></tr>
      <tr><td class="left">    const char *header,</td><td> </td><td class="right">    const char *header,</td></tr>
      <tr><td class="left">    const char *value);</td><td> </td><td class="right">    const char *value);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set, no copies.</td><td> </td><td class="right"> * Set, no copies.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Set the specified @a header and @a value into the bucket, without</td><td> </td><td class="right"> * Set the specified @a header and @a value into the bucket, without</td></tr>
      <tr><td class="left"> * copying either attribute. Both attributes should remain in scope at</td><td> </td><td class="right"> * copying either attribute. Both attributes should remain in scope at</td></tr>
      <tr><td class="left"> * least as long as the bucket.</td><td> </td><td class="right"> * least as long as the bucket.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note In the case where a header already exists this will result</td><td> </td><td class="right"> * @note In the case where a header already exists this will result</td></tr>
      <tr><td class="left"> *       in a reallocation and copy, @see serf_bucket_headers_setn.</td><td> </td><td class="right"> *       in a reallocation and copy, @see serf_bucket_headers_setn.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0052"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_headers_setn(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_headers_setn(</td></tr>
      <tr><td class="left">    serf_bucket_t *headers_bucket,</td><td> </td><td class="right">    serf_bucket_t *headers_bucket,</td></tr>
      <tr><td class="left">    const char *header,</td><td> </td><td class="right">    const char *header,</td></tr>
      <tr><td class="left">    const char *value);</td><td> </td><td class="right">    const char *value);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set, extended: fine grained copy control of header and value.</td><td> </td><td class="right"> * Set, extended: fine grained copy control of header and value.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Set the specified @a header, with length @a header_size with the</td><td> </td><td class="right"> * Set the specified @a header, with length @a header_size with the</td></tr>
      <tr><td class="left"> * @a value, and length @a value_size, into the bucket. The header will</td><td> </td><td class="right"> * @a value, and length @a value_size, into the bucket. The header will</td></tr>
      <tr><td class="left"> * be copied if @a header_copy is set, and the value is copied if</td><td> </td><td class="right"> * be copied if @a header_copy is set, and the value is copied if</td></tr>
      <tr><td class="left"> * @a value_copy is set. If the values are not copied, then they should</td><td> </td><td class="right"> * @a value_copy is set. If the values are not copied, then they should</td></tr>
      <tr><td class="left"> * remain in scope at least as long as the bucket.</td><td> </td><td class="right"> * remain in scope at least as long as the bucket.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If @a headers_bucket already contains a header with the same name</td><td> </td><td class="right"> * If @a headers_bucket already contains a header with the same name</td></tr>
      <tr><td class="left"> * as @a header, then append @a value to the existing value,</td><td> </td><td class="right"> * as @a header, then append @a value to the existing value,</td></tr>
      <tr><td class="left"> * separating with a comma (as per RFC 2616, section 4.2).  In this</td><td> </td><td class="right"> * separating with a comma (as per RFC 2616, section 4.2).  In this</td></tr>
      <tr><td class="left"> * case, the new value must be allocated and the header re-used, so</td><td> </td><td class="right"> * case, the new value must be allocated and the header re-used, so</td></tr>
      <tr><td class="left"> * behave as if @a value_copy were true and @a header_copy false.</td><td> </td><td class="right"> * behave as if @a value_copy were true and @a header_copy false.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0053"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_headers_setx(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_headers_setx(</td></tr>
      <tr><td class="left">    serf_bucket_t *headers_bucket,</td><td> </td><td class="right">    serf_bucket_t *headers_bucket,</td></tr>
      <tr id="diff0054"></tr>
      <tr><td class="lblock">    const char *header, apr_size_t header_size, int header_copy,</td><td> </td><td class="rblock">    const char *header,</td></tr>
      <tr><td class="lblock">    const char *value, apr_size_t value_size, int value_copy);</td><td> </td><td class="rblock">    apr_size_t header_size,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    int header_copy,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    const char *value,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t value_size,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    int value_copy);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0055"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(const char *) </span>serf_bucket_headers_get(</td><td> </td><td class="rblock"><span class="insert">const char *</span>serf_bucket_headers_get(</td></tr>
      <tr><td class="left">    serf_bucket_t *headers_bucket,</td><td> </td><td class="right">    serf_bucket_t *headers_bucket,</td></tr>
      <tr><td class="left">    const char *header);</td><td> </td><td class="right">    const char *header);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @param baton opaque baton as passed to @see serf_bucket_headers_do</td><td> </td><td class="right"> * @param baton opaque baton as passed to @see serf_bucket_headers_do</td></tr>
      <tr><td class="left"> * @param key The header key from this iteration through the table</td><td> </td><td class="right"> * @param key The header key from this iteration through the table</td></tr>
      <tr><td class="left"> * @param value The header value from this iteration through the table</td><td> </td><td class="right"> * @param value The header value from this iteration through the table</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef int (serf_bucket_headers_do_callback_fn_t)(</td><td> </td><td class="right">typedef int (serf_bucket_headers_do_callback_fn_t)(</td></tr>
      <tr><td class="left">    void *baton,</td><td> </td><td class="right">    void *baton,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 366<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 396<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Iterates over all headers of the message and invokes the callback</td><td> </td><td class="right"> * Iterates over all headers of the message and invokes the callback</td></tr>
      <tr><td class="left"> * function with header key and value. Stop iterating when no more</td><td> </td><td class="right"> * function with header key and value. Stop iterating when no more</td></tr>
      <tr><td class="left"> * headers are available or when the callback function returned a</td><td> </td><td class="right"> * headers are available or when the callback function returned a</td></tr>
      <tr><td class="left"> * non-0 value.</td><td> </td><td class="right"> * non-0 value.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param headers_bucket headers to iterate over</td><td> </td><td class="right"> * @param headers_bucket headers to iterate over</td></tr>
      <tr><td class="left"> * @param func callback routine to invoke for every header in the bucket</td><td> </td><td class="right"> * @param func callback routine to invoke for every header in the bucket</td></tr>
      <tr><td class="left"> * @param baton baton to pass on each invocation to func</td><td> </td><td class="right"> * @param baton baton to pass on each invocation to func</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0056"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_headers_do(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_headers_do(</td></tr>
      <tr><td class="left">    serf_bucket_t *headers_bucket,</td><td> </td><td class="right">    serf_bucket_t *headers_bucket,</td></tr>
      <tr><td class="left">    serf_bucket_headers_do_callback_fn_t func,</td><td> </td><td class="right">    serf_bucket_headers_do_callback_fn_t func,</td></tr>
      <tr><td class="left">    void *baton);</td><td> </td><td class="right">    void *baton);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0057"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_chunk;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_chunk;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_CHUNK(b) SERF_BUCKET_CHECK((b), chunk)</td><td> </td><td class="right">#define SERF_BUCKET_IS_CHUNK(b) SERF_BUCKET_CHECK((b), chunk)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0058"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_chunk_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_chunk_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0059"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_dechunk;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_dechunk;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_DECHUNK(b) SERF_BUCKET_CHECK((b), dechunk)</td><td> </td><td class="right">#define SERF_BUCKET_IS_DECHUNK(b) SERF_BUCKET_CHECK((b), dechunk)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0060"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_dechunk_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_dechunk_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0061"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_deflate;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_deflate;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_DEFLATE(b) SERF_BUCKET_CHECK((b), deflate)</td><td> </td><td class="right">#define SERF_BUCKET_IS_DEFLATE(b) SERF_BUCKET_CHECK((b), deflate)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define SERF_DEFLATE_GZIP 0</td><td> </td><td class="right">#define SERF_DEFLATE_GZIP 0</td></tr>
      <tr><td class="left">#define SERF_DEFLATE_DEFLATE 1</td><td> </td><td class="right">#define SERF_DEFLATE_DEFLATE 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0062"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_deflate_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_deflate_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator,</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator,</td></tr>
      <tr><td class="left">    int format);</td><td> </td><td class="right">    int format);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0063"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_limit;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_limit;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_LIMIT(b) SERF_BUCKET_CHECK((b), limit)</td><td> </td><td class="right">#define SERF_BUCKET_IS_LIMIT(b) SERF_BUCKET_CHECK((b), limit)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0064"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_limit_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_limit_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    apr_size_t limit,</td><td> </td><td class="right">    apr_size_t limit,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left">#define SERF_SSL_CERT_NOTYETVALID       1</td><td> </td><td class="right">#define SERF_SSL_CERT_NOTYETVALID       1</td></tr>
      <tr><td class="left">#define SERF_SSL_CERT_EXPIRED           2</td><td> </td><td class="right">#define SERF_SSL_CERT_EXPIRED           2</td></tr>
      <tr><td class="left">#define SERF_SSL_CERT_UNKNOWNCA         4</td><td> </td><td class="right">#define SERF_SSL_CERT_UNKNOWNCA         4</td></tr>
      <tr><td class="left">#define SERF_SSL_CERT_SELF_SIGNED       8</td><td> </td><td class="right">#define SERF_SSL_CERT_SELF_SIGNED       8</td></tr>
      <tr><td class="left">#define SERF_SSL_CERT_UNKNOWN_FAILURE  16</td><td> </td><td class="right">#define SERF_SSL_CERT_UNKNOWN_FAILURE  16</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0065"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_ssl_encr
</span>ypt;</td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_ssl_encr</span>ypt;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_SSL_ENCRYPT(b) SERF_BUCKET_CHECK((b), ssl_encrypt)</td><td> </td><td class="right">#define SERF_BUCKET_IS_SSL_ENCRYPT(b) SERF_BUCKET_CHECK((b), ssl_encrypt)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef struct serf_ssl_context_t serf_ssl_context_t;</td><td> </td><td class="right">typedef struct serf_ssl_context_t serf_ssl_context_t;</td></tr>
      <tr><td class="left">typedef struct serf_ssl_certificate_t serf_ssl_certificate_t;</td><td> </td><td class="right">typedef struct serf_ssl_certificate_t serf_ssl_certificate_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0066"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_ssl_need_client_cert_t)(void</span> *data,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_ssl_need_client_cert_t)(</span></td></tr>
      <tr><td class="lblock">                                                    const char <span class="delete">**cert_path)</span></td><td> </td><td class="rblock"><span class="insert">    void</span> *data,</td></tr>
      <tr><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock">    const char <span class="insert">**cert_path);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0067"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_ssl_need_cert_password_t)(void</span> *data,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_ssl_need_cert_password_t)(</span></td></tr>
      <tr><td class="lblock">                                                      const char <span class="delete">*cert_path</span></td><td> </td><td class="rblock"><span class="insert">    void</span> *data,</td></tr>
      <tr><td class="lblock"><span class="delete">,</span></td><td> </td><td class="rblock">    const char <span class="insert">*cert_path,</span></td></tr>
      <tr><td class="lblock">                                                      const char <span class="delete">**password</span></td><td> </td><td class="rblock">    const char <span class="insert">**password);</span></td></tr>
      <tr><td class="lblock"><span class="delete">);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0068"></tr>
      <tr><td class="lblock">typedef apr_status_t</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_ssl_need_server_cert_t)(</span></td></tr>
      <tr><td class="lblock"><span class="delete">(*serf_ssl_need_server_cert_t)(void</span> *data,</td><td> </td><td class="rblock"><span class="insert">    void</span> *data,</td></tr>
      <tr><td class="lblock">                               int failures,</td><td> </td><td class="rblock">    int failures,</td></tr>
      <tr><td class="lblock">                               const serf_ssl_certificate_t *cert);</td><td> </td><td class="rblock">    const serf_ssl_certificate_t *cert);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0069"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span></td><td> </td><td class="rblock"><span class="insert">void serf_ssl_client_cert_provider_set(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_client_cert_provider_set(serf_ssl_context_t</span> *context,</td><td> </td><td class="rblock"><span class="insert">    serf_ssl_context_t</span> *context,</td></tr>
      <tr><td class="lblock">                                  serf_ssl_need_client_cert_t callback,</td><td> </td><td class="rblock">    serf_ssl_need_client_cert_t <span class="insert">callback,</span></td></tr>
      <tr><td class="lblock">                                  void *data,</td><td> </td><td class="rblock"><span class="insert">    void *data,</span></td></tr>
      <tr><td class="lblock">                                  void *cache_pool);</td><td> </td><td class="rblock"><span class="insert">    void *cache_pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void serf_ssl_client_cert_password_set(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_ssl_context_t *context,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_ssl_need_cert_password_t</span> callback,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    void *data,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    void *cache_pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0070"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_client_cert_password_set(serf_ssl_context_t *context,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                                  serf_ssl_need_cert_password_t callback,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                                  void *data,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                                  void *cache_pool);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set a callback to override the default SSL server certificate validation</td><td> </td><td class="right"> * Set a callback to override the default SSL server certificate validation</td></tr>
      <tr><td class="left"> * algorithm.</td><td> </td><td class="right"> * algorithm.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0071"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span></td><td> </td><td class="rblock"><span class="insert">void serf_ssl_server_cert_callback_set(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_server_cert_callback_set(serf_ssl_context_t</span> *context,</td><td> </td><td class="rblock"><span class="insert">    serf_ssl_context_t</span> *context,</td></tr>
      <tr><td class="lblock">                                  serf_ssl_need_server_cert_t callback,</td><td> </td><td class="rblock">    serf_ssl_need_server_cert_t callback,</td></tr>
      <tr><td class="lblock">                                  void *data);</td><td> </td><td class="rblock">    void *data);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Use the default root CA certificates as included with the OpenSSL librar
y.</td><td> </td><td class="right"> * Use the default root CA certificates as included with the OpenSSL librar
y.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0072"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_ssl_use_default_certificates(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_use_default_certificates(serf_ssl_context_t</span> *context);</td><td> </td><td class="rblock"><span class="insert">    serf_ssl_context_t</span> *context);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the depth of the certificate.</td><td> </td><td class="right"> * Return the depth of the certificate.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0073"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(int) serf_ssl_cert_depth(const</span> serf_ssl_certificate_t *cert);</td><td> </td><td class="rblock"><span class="insert">int serf_ssl_cert_depth(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const</span> serf_ssl_certificate_t *cert);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Extract the fields of the issuer in a table with keys (E, CN, OU, O, L,</td><td> </td><td class="right"> * Extract the fields of the issuer in a table with keys (E, CN, OU, O, L,</td></tr>
      <tr><td class="left"> * ST and C). The returned table will be allocated in @a pool.</td><td> </td><td class="right"> * ST and C). The returned table will be allocated in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0074"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_hash_t *)</span></td><td> </td><td class="rblock"><span class="insert">apr_hash_t *serf_ssl_cert_issuer(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_cert_issuer(const</span> serf_ssl_certificate_t *cert, apr_pool_t *pool);</td><td> </td><td class="rblock"><span class="insert">    const</span> serf_ssl_certificate_t *cert,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Extract the fields of the subject in a table with keys (E, CN, OU, O, L,</td><td> </td><td class="right"> * Extract the fields of the subject in a table with keys (E, CN, OU, O, L,</td></tr>
      <tr><td class="left"> * ST and C). The returned table will be allocated in @a pool.</td><td> </td><td class="right"> * ST and C). The returned table will be allocated in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0075"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_hash_t *)</span></td><td> </td><td class="rblock"><span class="insert">apr_hash_t *serf_ssl_cert_subject(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_cert_subject(const</span> serf_ssl_certificate_t *cert, apr_pool_t <span class="delete">*pool)</span></td><td> </td><td class="rblock"><span class="insert">    const</span> serf_ssl_certificate_t *cert,</td></tr>
      <tr><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock">    apr_pool_t <span class="insert">*pool);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Extract the fields of the certificate in a table with keys (sha1, notBef
ore,</td><td> </td><td class="right"> * Extract the fields of the certificate in a table with keys (sha1, notBef
ore,</td></tr>
      <tr><td class="left"> * notAfter). The returned table will be allocated in @a pool.</td><td> </td><td class="right"> * notAfter). The returned table will be allocated in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0076"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_hash_t *)</span></td><td> </td><td class="rblock"><span class="insert">apr_hash_t *serf_ssl_cert_certificate(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_cert_certificate(const</span> serf_ssl_certificate_t *cert, apr_pool_t <span class="delete">*p</span></td><td> </td><td class="rblock"><span class="insert">    const</span> serf_ssl_certificate_t *cert,</td></tr>
      <tr><td class="lblock"><span class="delete">ool);</span></td><td> </td><td class="rblock">    apr_pool_t <span class="insert">*pool);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Export a certificate to base64-encoded, zero-terminated string.</td><td> </td><td class="right"> * Export a certificate to base64-encoded, zero-terminated string.</td></tr>
      <tr><td class="left"> * The returned string is allocated in @a pool. Returns NULL on failure.</td><td> </td><td class="right"> * The returned string is allocated in @a pool. Returns NULL on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0077"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(const</span> char <span class="delete">*)</span></td><td> </td><td class="rblock"><span class="insert">const</span> char <span class="insert">*serf_ssl_cert_export(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_cert_export(const</span> serf_ssl_certificate_t *cert, apr_pool_t *pool);</td><td> </td><td class="rblock"><span class="insert">    const</span> serf_ssl_certificate_t *cert,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Load a CA certificate file from a path @a file_path. If the file was loa
ded</td><td> </td><td class="right"> * Load a CA certificate file from a path @a file_path. If the file was loa
ded</td></tr>
      <tr><td class="left"> * and parsed correctly, a certificate @a cert will be created and returned
.</td><td> </td><td class="right"> * and parsed correctly, a certificate @a cert will be created and returned
.</td></tr>
      <tr><td class="left"> * This certificate object will be alloced in @a pool.</td><td> </td><td class="right"> * This certificate object will be alloced in @a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0078"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_ssl_load_cert_file(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_load_cert_file(serf_ssl_certificate_t</span> **cert, const char <span class="delete">*file_pat</span></td><td> </td><td class="rblock"><span class="insert">    serf_ssl_certificate_t</span> **cert,</td></tr>
      <tr><td class="lblock"><span class="delete">h,</span></td><td> </td><td class="rblock">    const char <span class="insert">*file_path,</span></td></tr>
      <tr><td class="lblock">                        apr_pool_t *pool);</td><td> </td><td class="rblock">    apr_pool_t *pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Adds the certificate @a cert to the list of trusted certificates in</td><td> </td><td class="right"> * Adds the certificate @a cert to the list of trusted certificates in</td></tr>
      <tr><td class="left"> * @a ssl_ctx that will be used for verification.</td><td> </td><td class="right"> * @a ssl_ctx that will be used for verification.</td></tr>
      <tr><td class="left"> * See also @a serf_ssl_load_cert_file.</td><td> </td><td class="right"> * See also @a serf_ssl_load_cert_file.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0079"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_ssl_trust_cert(</span></td></tr>
      <tr><td class="lblock"><span class="delete">serf_ssl_trust_cert(serf_ssl_context_t</span> *ssl_ctx, serf_ssl_certificate_t <span class="delete">*ce</span></td><td> </td><td class="rblock"><span class="insert">    serf_ssl_context_t</span> *ssl_ctx,</td></tr>
      <tr><td class="lblock"><span class="delete">rt);</span></td><td> </td><td class="rblock">    serf_ssl_certificate_t <span class="insert">*cert);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0080"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_ssl_encrypt_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_ssl_encrypt_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_ssl_context_t *ssl_context,</td><td> </td><td class="right">    serf_ssl_context_t *ssl_context,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0081"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_ssl_context_t *) </span>serf_bucket_ssl_encrypt_context_get(</td><td> </td><td class="rblock"><span class="insert">serf_ssl_context_t *</span>serf_bucket_ssl_encrypt_context_get(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket);</td><td> </td><td class="right">    serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0082"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA extern const serf_bucket_type_t serf_bucket_type_ssl_decr
</span>ypt;</td><td> </td><td class="rblock"><span class="insert">extern const serf_bucket_type_t serf_bucket_type_ssl_decr</span>ypt;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_SSL_DECRYPT(b) SERF_BUCKET_CHECK((b), ssl_decrypt)</td><td> </td><td class="right">#define SERF_BUCKET_IS_SSL_DECRYPT(b) SERF_BUCKET_CHECK((b), ssl_decrypt)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0083"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_ssl_decrypt_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_ssl_decrypt_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_ssl_context_t *ssl_context,</td><td> </td><td class="right">    serf_ssl_context_t *ssl_context,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0084"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_ssl_context_t *) </span>serf_bucket_ssl_decrypt_context_get(</td><td> </td><td class="rblock"><span class="insert">serf_ssl_context_t *</span>serf_bucket_ssl_decrypt_context_get(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket);</td><td> </td><td class="right">    serf_bucket_t *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0085"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE_DATA </span>extern const serf_bucket_type_t serf_bucket_type_barrier;</td><td> </td><td class="rblock">extern const serf_bucket_type_t serf_bucket_type_barrier;</td></tr>
      <tr><td class="left">#define SERF_BUCKET_IS_BARRIER(b) SERF_BUCKET_CHECK((b), barrier)</td><td> </td><td class="right">#define SERF_BUCKET_IS_BARRIER(b) SERF_BUCKET_CHECK((b), barrier)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0086"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_barrier_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_barrier_create(</td></tr>
      <tr><td class="left">    serf_bucket_t *stream,</td><td> </td><td class="right">    serf_bucket_t *stream,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator);</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ==================================================================== */</td><td> </td><td class="right">/* ==================================================================== */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* ### do we need a PIPE bucket type? they are simple apr_file_t objects */</td><td> </td><td class="right">/* ### do we need a PIPE bucket type? they are simple apr_file_t objects */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 86 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>134 lines changed or deleted</i></th><th><i> </i></th><th><i>163 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;serf_bucket_util.h (0.4.0)&nbsp;</th><th> </th><th>&nbsp;serf_bucket_util.h (0.7.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 27<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 27<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define SERF_BUCKET_UTIL_H</td><td> </td><td class="right">#define SERF_BUCKET_UTIL_H</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @file serf_bucket_util.h</td><td> </td><td class="right"> * @file serf_bucket_util.h</td></tr>
      <tr><td class="left"> * @brief This header defines a set of functions and other utilities</td><td> </td><td class="right"> * @brief This header defines a set of functions and other utilities</td></tr>
      <tr><td class="left"> * for implementing buckets. It is not needed by users of the bucket</td><td> </td><td class="right"> * for implementing buckets. It is not needed by users of the bucket</td></tr>
      <tr><td class="left"> * system.</td><td> </td><td class="right"> * system.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include "serf.h"</td><td> </td><td class="right">#include "serf.h"</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"><span class="delete">#include "serf_declare.h"</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Basic bucket creation function.</td><td> </td><td class="right"> * Basic bucket creation function.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will create a bucket of @a type, allocating the necessary</td><td> </td><td class="right"> * This function will create a bucket of @a type, allocating the necessary</td></tr>
      <tr><td class="left"> * memory from @a allocator. The @a data bucket-private information will</td><td> </td><td class="right"> * memory from @a allocator. The @a data bucket-private information will</td></tr>
      <tr><td class="left"> * be stored into the bucket.</td><td> </td><td class="right"> * be stored into the bucket.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_bucket_create(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_bucket_create(</td></tr>
      <tr><td class="left">    const serf_bucket_type_t *type,</td><td> </td><td class="right">    const serf_bucket_type_t *type,</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator,</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator,</td></tr>
      <tr><td class="left">    void *data);</td><td> </td><td class="right">    void *data);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Default implementation of the @see read_iovec functionality.</td><td> </td><td class="right"> * Default implementation of the @see read_iovec functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will use the @see read function to get a block of memory,</td><td> </td><td class="right"> * This function will use the @see read function to get a block of memory,</td></tr>
      <tr><td class="left"> * then return it in the iovec.</td><td> </td><td class="right"> * then return it in the iovec.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_default_read_iovec(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_default_read_iovec(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    apr_size_t requested,</td><td> </td><td class="right">    apr_size_t requested,</td></tr>
      <tr><td class="left">    int vecs_size,</td><td> </td><td class="right">    int vecs_size,</td></tr>
      <tr><td class="left">    struct iovec *vecs,</td><td> </td><td class="right">    struct iovec *vecs,</td></tr>
      <tr><td class="left">    int *vecs_used);</td><td> </td><td class="right">    int *vecs_used);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Default implementation of the @see read_for_sendfile functionality.</td><td> </td><td class="right"> * Default implementation of the @see read_for_sendfile functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will use the @see read function to get a block of memory,</td><td> </td><td class="right"> * This function will use the @see read function to get a block of memory,</td></tr>
      <tr><td class="left"> * then return it as a header. No file will be returned.</td><td> </td><td class="right"> * then return it as a header. No file will be returned.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t)</span> serf_default_read_for_sendfile(</td><td> </td><td class="rblock"><span class="insert">apr_status_t</span> serf_default_read_for_sendfile(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    apr_size_t requested,</td><td> </td><td class="right">    apr_size_t requested,</td></tr>
      <tr><td class="left">    apr_hdtr_t *hdtr,</td><td> </td><td class="right">    apr_hdtr_t *hdtr,</td></tr>
      <tr><td class="left">    apr_file_t **file,</td><td> </td><td class="right">    apr_file_t **file,</td></tr>
      <tr><td class="left">    apr_off_t *offset,</td><td> </td><td class="right">    apr_off_t *offset,</td></tr>
      <tr><td class="left">    apr_size_t *len);</td><td> </td><td class="right">    apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Default implementation of the @see read_bucket functionality.</td><td> </td><td class="right"> * Default implementation of the @see read_bucket functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will always return NULL, indicating that the @a type</td><td> </td><td class="right"> * This function will always return NULL, indicating that the @a type</td></tr>
      <tr><td class="left"> * of bucket cannot be found within @a bucket.</td><td> </td><td class="right"> * of bucket cannot be found within @a bucket.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(serf_bucket_t *) </span>serf_default_read_bucket(</td><td> </td><td class="rblock"><span class="insert">serf_bucket_t *</span>serf_default_read_bucket(</td></tr>
      <tr><td class="left">    serf_bucket_t *bucket,</td><td> </td><td class="right">    serf_bucket_t *bucket,</td></tr>
      <tr><td class="left">    const serf_bucket_type_t *type);</td><td> </td><td class="right">    const serf_bucket_type_t *type);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Default implementation of the @see destroy functionality.</td><td> </td><td class="right"> * Default implementation of the @see destroy functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will return the @a bucket to its allcoator.</td><td> </td><td class="right"> * This function will return the @a bucket to its allcoator.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_default_destroy(serf_bucket_t</span> *bucket);</td><td> </td><td class="rblock"><span class="insert">void serf_default_destroy(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Default implementation of the @see destroy functionality.</td><td> </td><td class="right"> * Default implementation of the @see destroy functionality.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will return the @a bucket, and the data member to its</td><td> </td><td class="right"> * This function will return the @a bucket, and the data member to its</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"> * all<span class="delete">co</span>ator.</td><td> </td><td class="rblock"> * all<span class="insert">oc</span>ator.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_default_destroy_and_data(serf_bucket_t</span> *bucket);</td><td> </td><td class="rblock"><span class="insert">void serf_default_destroy_and_data(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Default implementation of the @see snapshot functionality</td><td> </td><td class="right"> * Default implementation of the @see snapshot functionality</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will return an error to indicate it's not implemented.</td><td> </td><td class="right"> * This function will return an error to indicate it's not implemented.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_default_snapshot(serf_bucket_t</span> *bucket);</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_default_snapshot(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> * Default implementation of the @see restore_snapshot functionality</td><td> </td><td class="right"> * Default implementation of the @see restore_snapshot functionality</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will return an error to indicate it's not implemented.</td><td> </td><td class="right"> * This function will return an error to indicate it's not implemented.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_default_restore_snapshot(serf_bucket_t *buc</span></td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_default_restore_snapshot(</span></td></tr>
      <tr><td class="lblock"><span class="delete">ket);</span></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t *bucket);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> * Default implementation of the @see is_snapshot_set functionality</td><td> </td><td class="right"> * Default implementation of the @see is_snapshot_set functionality</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function will return 0 (no snapshot set).</td><td> </td><td class="right"> * This function will return 0 (no snapshot set).</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(int) serf_default_is_snapshot_set(serf_bucket_t</span> *bucket);</td><td> </td><td class="rblock"><span class="insert">int serf_default_is_snapshot_set(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_bucket_t</span> *bucket);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Allocate @a size bytes of memory using @a allocator.</td><td> </td><td class="right"> * Allocate @a size bytes of memory using @a allocator.</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns NULL of the requested memory size could not be allocated.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void *) </span>serf_bucket_mem_alloc(</td><td> </td><td class="rblock"><span class="insert">void *</span>serf_bucket_mem_alloc(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator,</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator,</td></tr>
      <tr><td class="left">    apr_size_t size);</td><td> </td><td class="right">    apr_size_t size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Allocate @a size bytes of memory using @a allocator and set all of the</td><td> </td><td class="right"> * Allocate @a size bytes of memory using @a allocator and set all of the</td></tr>
      <tr><td class="left"> * memory to 0.</td><td> </td><td class="right"> * memory to 0.</td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns NULL of the requested memory size could not be allocated.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void *) </span>serf_bucket_mem_calloc(</td><td> </td><td class="rblock"><span class="insert">void *</span>serf_bucket_mem_calloc(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator,</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator,</td></tr>
      <tr><td class="left">    apr_size_t size);</td><td> </td><td class="right">    apr_size_t size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Free the memory at @a block, returning it to @a allocator.</td><td> </td><td class="right"> * Free the memory at @a block, returning it to @a allocator.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void)</span> serf_bucket_mem_free(</td><td> </td><td class="rblock"><span class="insert">void</span> serf_bucket_mem_free(</td></tr>
      <tr><td class="left">    serf_bucket_alloc_t *allocator,</td><td> </td><td class="right">    serf_bucket_alloc_t *allocator,</td></tr>
      <tr><td class="left">    void *block);</td><td> </td><td class="right">    void *block);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Analogous to apr_pstrmemdup, using a bucket allocator instead.</td><td> </td><td class="right"> * Analogous to apr_pstrmemdup, using a bucket allocator instead.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(char *) serf_bstrmemdup(serf_bucket_alloc_t</span> *allocator,</td><td> </td><td class="rblock"><span class="insert">char *serf_bstrmemdup(</span></td></tr>
      <tr><td class="lblock">                                     const char *str,</td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t</span> *allocator,</td></tr>
      <tr><td class="lblock">                                     apr_size_t size);</td><td> </td><td class="rblock">    const char *str,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Analogous to apr_pmemdup, using a bucket allocator instead.</td><td> </td><td class="right"> * Analogous to apr_pmemdup, using a bucket allocator instead.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void *) serf_bmemdup(serf_bucket_alloc_t</span> *allocator,</td><td> </td><td class="rblock"><span class="insert">void * serf_bmemdup(</span></td></tr>
      <tr><td class="lblock">                                  const void *mem,</td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t</span> *allocator,</td></tr>
      <tr><td class="lblock">                                  apr_size_t size);</td><td> </td><td class="rblock">    const void *mem,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Analogous to apr_pstrdup, using a bucket allocator instead.</td><td> </td><td class="right"> * Analogous to apr_pstrdup, using a bucket allocator instead.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(char *) serf_bstrdup(serf_bucket_alloc_t</span> *allocator,</td><td> </td><td class="rblock"><span class="insert">char * serf_bstrdup(</span></td></tr>
      <tr><td class="lblock">                                  const char *str);</td><td> </td><td class="rblock"><span class="insert">    serf_bucket_alloc_t</span> *allocator,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    const char *str);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Read data up to a newline.</td><td> </td><td class="right"> * Read data up to a newline.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @a acceptable contains the allowed forms of a newline, and @a found</td><td> </td><td class="right"> * @a acceptable contains the allowed forms of a newline, and @a found</td></tr>
      <tr><td class="left"> * will return the particular newline type that was found. If a newline</td><td> </td><td class="right"> * will return the particular newline type that was found. If a newline</td></tr>
      <tr><td class="left"> * is not found, then SERF_NEWLINE_NONE will be placed in @a found.</td><td> </td><td class="right"> * is not found, then SERF_NEWLINE_NONE will be placed in @a found.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @a data should contain a pointer to the data to be scanned. @a len</td><td> </td><td class="right"> * @a data should contain a pointer to the data to be scanned. @a len</td></tr>
      <tr><td class="left"> * should specify the length of that data buffer. On exit, @a data will</td><td> </td><td class="right"> * should specify the length of that data buffer. On exit, @a data will</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 188<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 199<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * This function scans at a byte level for the newline characters. Thus,</td><td> </td><td class="right"> * This function scans at a byte level for the newline characters. Thus,</td></tr>
      <tr><td class="left"> * the data buffer may contain NUL characters. As a corollary, this</td><td> </td><td class="right"> * the data buffer may contain NUL characters. As a corollary, this</td></tr>
      <tr><td class="left"> * function only works on 8-bit character encodings.</td><td> </td><td class="right"> * function only works on 8-bit character encodings.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If the data is fully consumed (@a len gets set to zero) and a CR</td><td> </td><td class="right"> * If the data is fully consumed (@a len gets set to zero) and a CR</td></tr>
      <tr><td class="left"> * character is found at the end and the CRLF sequence is allowed, then</td><td> </td><td class="right"> * character is found at the end and the CRLF sequence is allowed, then</td></tr>
      <tr><td class="left"> * this function may store SERF_NEWLINE_CRLF_SPLIT into @a found. The</td><td> </td><td class="right"> * this function may store SERF_NEWLINE_CRLF_SPLIT into @a found. The</td></tr>
      <tr><td class="left"> * caller should take particular consideration for the CRLF sequence</td><td> </td><td class="right"> * caller should take particular consideration for the CRLF sequence</td></tr>
      <tr><td class="left"> * that may be split across data buffer boundaries.</td><td> </td><td class="right"> * that may be split across data buffer boundaries.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_util_readline(const</span> char **data, apr_size_t *len,</td><td> </td><td class="rblock"><span class="insert">void serf_util_readline(</span></td></tr>
      <tr><td class="lblock">                                      int acceptable, int *found);</td><td> </td><td class="rblock"><span class="insert">    const</span> char **data,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t *len,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    int acceptable,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    int *found);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The buffer size used within @see serf_databuf_t. */</td><td> </td><td class="right">/** The buffer size used within @see serf_databuf_t. */</td></tr>
      <tr><td class="left">#define SERF_DATABUF_BUFSIZE 8000</td><td> </td><td class="right">#define SERF_DATABUF_BUFSIZE 8000</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Callback function which is used to refill the data buffer.</td><td> </td><td class="right">/** Callback function which is used to refill the data buffer.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The function takes @a baton, which is the @see read_baton value</td><td> </td><td class="right"> * The function takes @a baton, which is the @see read_baton value</td></tr>
      <tr><td class="left"> * from the serf_databuf_t structure. Data should be placed into</td><td> </td><td class="right"> * from the serf_databuf_t structure. Data should be placed into</td></tr>
      <tr><td class="left"> * a buffer specified by @a buf, which is @a bufsize bytes long.</td><td> </td><td class="right"> * a buffer specified by @a buf, which is @a bufsize bytes long.</td></tr>
      <tr><td class="left"> * The amount of data read should be returned in @a len.</td><td> </td><td class="right"> * The amount of data read should be returned in @a len.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * APR_EOF should be returned if no more data is available. APR_EAGAIN</td><td> </td><td class="right"> * APR_EOF should be returned if no more data is available. APR_EAGAIN</td></tr>
      <tr><td class="left"> * should be returned, rather than blocking. In both cases, @a buf</td><td> </td><td class="right"> * should be returned, rather than blocking. In both cases, @a buf</td></tr>
      <tr><td class="left"> * should be filled in and @a len set, as appropriate.</td><td> </td><td class="right"> * should be filled in and @a len set, as appropriate.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock">typedef apr_status_t <span class="delete">(*serf_databuf_reader_t)(void</span> *baton,</td><td> </td><td class="rblock">typedef apr_status_t <span class="insert">(*serf_databuf_reader_t)(</span></td></tr>
      <tr><td class="lblock">                                              apr_size_t bufsize,</td><td> </td><td class="rblock"><span class="insert">    void</span> *baton,</td></tr>
      <tr><td class="lblock">                                              char *buf,</td><td> </td><td class="rblock">    apr_size_t bufsize,</td></tr>
      <tr><td class="lblock">                                              apr_size_t *len);</td><td> </td><td class="rblock">    char *buf,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * This structure is used as an intermediate data buffer for some "external
"</td><td> </td><td class="right"> * This structure is used as an intermediate data buffer for some "external
"</td></tr>
      <tr><td class="left"> * source of data. It works as a scratch pad area for incoming data to be</td><td> </td><td class="right"> * source of data. It works as a scratch pad area for incoming data to be</td></tr>
      <tr><td class="left"> * stored, and then returned as a ptr/len pair by the bucket read functions
.</td><td> </td><td class="right"> * stored, and then returned as a ptr/len pair by the bucket read functions
.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This structure should be initialized by calling @see serf_databuf_init.</td><td> </td><td class="right"> * This structure should be initialized by calling @see serf_databuf_init.</td></tr>
      <tr><td class="left"> * Users should not bother to zero the structure beforehand.</td><td> </td><td class="right"> * Users should not bother to zero the structure beforehand.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 242<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 257<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    apr_status_t status;</td><td> </td><td class="right">    apr_status_t status;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    /** Holds the data until it can be returned. */</td><td> </td><td class="right">    /** Holds the data until it can be returned. */</td></tr>
      <tr><td class="left">    char buf[SERF_DATABUF_BUFSIZE];</td><td> </td><td class="right">    char buf[SERF_DATABUF_BUFSIZE];</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} serf_databuf_t;</td><td> </td><td class="right">} serf_databuf_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Initialize the @see serf_databuf_t structure specified by @a databuf.</td><td> </td><td class="right"> * Initialize the @see serf_databuf_t structure specified by @a databuf.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(void) serf_databuf_init(serf_databuf_t</span> *databuf);</td><td> </td><td class="rblock"><span class="insert">void serf_databuf_init(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    serf_databuf_t</span> *databuf);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Implement a bucket-style read function from the @see serf_databuf_t</td><td> </td><td class="right"> * Implement a bucket-style read function from the @see serf_databuf_t</td></tr>
      <tr><td class="left"> * structure given by @a databuf.</td><td> </td><td class="right"> * structure given by @a databuf.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The @a requested, @a data, and @a len fields are interpreted and used</td><td> </td><td class="right"> * The @a requested, @a data, and @a len fields are interpreted and used</td></tr>
      <tr><td class="left"> * as in the read function of @see serf_bucket_t.</td><td> </td><td class="right"> * as in the read function of @see serf_bucket_t.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_databuf_read(serf_databuf_t</span> *databuf,</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_databuf_read(</span></td></tr>
      <tr><td class="lblock">                                             apr_size_t requested,</td><td> </td><td class="rblock"><span class="insert">    serf_databuf_t</span> *databuf,</td></tr>
      <tr><td class="lblock">                                             const char **data,</td><td> </td><td class="rblock">    apr_size_t requested,</td></tr>
      <tr><td class="lblock">                                             apr_size_t *len);</td><td> </td><td class="rblock">    const char **data,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Implement a bucket-style readline function from the @see serf_databuf_t</td><td> </td><td class="right"> * Implement a bucket-style readline function from the @see serf_databuf_t</td></tr>
      <tr><td class="left"> * structure given by @a databuf.</td><td> </td><td class="right"> * structure given by @a databuf.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The @a acceptable, @a found, @a data, and @a len fields are interpreted</td><td> </td><td class="right"> * The @a acceptable, @a found, @a data, and @a len fields are interpreted</td></tr>
      <tr><td class="left"> * and used as in the read function of @see serf_bucket_t.</td><td> </td><td class="right"> * and used as in the read function of @see serf_bucket_t.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_databuf_readline(serf_databuf_t</span> *databuf,</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_databuf_readline(</span></td></tr>
      <tr><td class="lblock">                                                 int acceptable, int <span class="delete">*found</span></td><td> </td><td class="rblock"><span class="insert">    serf_databuf_t</span> *databuf,</td></tr>
      <tr><td class="lblock"><span class="delete">,</span></td><td> </td><td class="rblock">    int acceptable,</td></tr>
      <tr><td class="lblock">                                                 const char **data,</td><td> </td><td class="rblock">    int <span class="insert">*found,</span></td></tr>
      <tr><td class="lblock">                                                 apr_size_t *len);</td><td> </td><td class="rblock">    const char **data,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Implement a bucket-style peek function from the @see serf_databuf_t</td><td> </td><td class="right"> * Implement a bucket-style peek function from the @see serf_databuf_t</td></tr>
      <tr><td class="left"> * structure given by @a databuf.</td><td> </td><td class="right"> * structure given by @a databuf.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The @a data, and @a len fields are interpreted and used as in the</td><td> </td><td class="right"> * The @a data, and @a len fields are interpreted and used as in the</td></tr>
      <tr><td class="left"> * peek function of @see serf_bucket_t.</td><td> </td><td class="right"> * peek function of @see serf_bucket_t.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr id="diff0025"></tr>
      <tr><td class="lblock"><span class="delete">SERF_DECLARE(apr_status_t) serf_databuf_peek(serf_databuf_t</span> *databuf,</td><td> </td><td class="rblock"><span class="insert">apr_status_t serf_databuf_peek(</span></td></tr>
      <tr><td class="lblock">                                             const char **data,</td><td> </td><td class="rblock"><span class="insert">    serf_databuf_t</span> *databuf,</td></tr>
      <tr><td class="lblock">                                             apr_size_t *len);</td><td> </td><td class="rblock">    const char **data,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    apr_size_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif /* !SERF_BUCKET_UTIL_H */</td><td> </td><td class="right">#endif /* !SERF_BUCKET_UTIL_H */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 25 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>42 lines changed or deleted</i></th><th><i> </i></th><th><i>60 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><div style='width:100%;' align='left' class='small'>This html diff was produced by rfcdiff 1.41.The latest version is available from <a href='http://tools.ietf.org/tools/rfcdiff/'>http://tools.ietf.org/tools/rfcdiff/</a></div>
</td></tr></table>
</body>
</html>
